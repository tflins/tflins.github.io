{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"闲言碎语","text":"20年10月21日平行时空的我，或许是内心深处的自己。– 林俊杰 《暂时的记号》20年06月19日又到了人生的一个关键选择点20年03月18日当我们有一把锤子，看什么都是钉子20年02月10日这阵子大脑处于放空状态，竟连火车票都忘了退，损失 643 元，以此为戒！20年02月02日真的是魔幻现实主义20年01月13日山河岁月空惆怅，今生今世已惘然19年12月18日好好休息，认真睡觉，保命要紧19年12月16日终于切身体会到当初田老师说的那句毕业之后时间会越来越快19年07月12日沧海一粟，深漂一员","link":"/chitchat/index.html"},{"title":"关于","text":"能来到这儿的人，对于您的到来，实在是令人高兴。这意味着在茫茫人海中，我们有着一定的缘分，有机会，希望我们能成为朋友！博客自 2016 年起开始写博客(前域名 tflin.top)，之前用的是 WordPress ，由于没做好备份导致博客数据丢失。2018 起使用 hexo 重新搭建博客并托管至 GitHub Page ，用于记录自己在学习、生活中的思考。本博客已被 Google 收录，大部分的文章都是前端相关，希望所写的文章能够搜到这的朋友一些帮助或启发。自己97 年，19 届计算机专业毕业生，目前是前端工程师一枚，喜欢有趣的人，有趣的事，吉他爱好者，爱玩游戏，林俊杰歌迷。曾沉迷于文明5不能自拔，最开心的时候莫过于大学期间和室友一起联机打文明5的日子。也爱玩王者荣耀，最高王者五十多星，主打野，省级露娜。言谢托管支持：GitHub博客系统：hexo主题提供：icarusCDN支持：ailiyun联系我QQ: 1272334047 &nbsp;&nbsp;&nbsp;&nbsp;E-mail: im.tflin@gmail.com &nbsp;&nbsp;&nbsp;&nbsp;","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"","text":"毕业一年，有感前言2020年8月31日，8月的最后一天，写下这篇文章。其实也没什么事，只是觉得需要静下心来好好审视自己。毕业一年一个月半，依然记得当初刚毕业初来深圳时，被骗的经历，那个车站抱着孩子说没钱回家的女人。一年前的我不过脑子的傻乎乎的就去帮助了，如今的自己又会怎么做？我想应该会先去思考事情的真伪，加以试探再以适合的方式去帮助，而不是傻乎乎的直接给钱。// 2020年8月31日，8月的最后一天，写下这篇文章。其实也没什么事，只是觉得需要静下心来好好审视自己。// 毕业一年一个月半，依然记得当初刚毕业初来深圳时，被骗的经历，那个车站抱着孩子说没钱回家的女人。一年前的我不过脑子的傻乎乎的就去帮助了，如今的自己又会怎么做？我想应该会先去思考事情的真伪，加以试探再以适合的方式去帮助，而不是傻乎乎的直接给钱。// 总比他人要敏感的心，总是在想，自己这样做，是不是会影响到别人。敏感多顾忌，作为一个男生来说，很不好// 最大的敌人是自己。// 你在你的领域加油，我在我的领域加油。// 天下兴亡匹夫有责// 2020-08-31 23:07:49 完","link":"/todo/毕业一年，有感.html"},{"title":"作品集","text":"学生时代静态页面极简静态博客游戏面向对象的简单贪吃蛇(PC端)（预览地址）jQuery 打地鼠（预览地址）JavaScript 插件原生 JavaScript lightbox 弹出层预览插件（预览地址）前后端完整项目Node.js + express + mongodb 博客系统（源码地址）Vue 全家桶 + Node.js + Koa2 + mongodb 的音乐歌单分享播放器（预览地址）以上项目已托管在我的 Github 上 https://github.com/tflins","link":"/works/index.html"}],"posts":[{"title":"ES6 Promise 对象","text":"前言ES6 都出来三年了，在 ES6 中将 Promise 正式列为标准，这也就意味着 JavaScript 的异步编程又有一种新的写法，且这种写法更加的优雅，更易于维护。毕竟，Node.js 中大部分都是异步的。我写这篇文章主要对 Promise 对象进行系统的叙述讨论，并以此展开 JavaScriot 的运行机制。从而提高自己的知识水平，毕竟，人总是在积累、总结中成长的。单线程的 JavaScript由于 JavaScript 中充斥着很多的 DOM 操作，为了避免进程之间的死锁，所以将其设计成了单线程。而单线程就意味着一次只能处理一个任务，等上一个任务处理完成后，才进行下一个任务的处理。为了优化处理任务的速度，将两种，一种同步任务，另一种是异步任务。其中，同步任务在主线程上排队等待执行，而异步任务则将其挂起，放进任务队列中，只有任务队列中通知主线程，某个异步任务可以执行时，才将放入主进程中执行。回调地狱回调函数，就是那些被主线程挂起来的代码，异步任务必须指定其回调函数，当主线程开始执行异步时，就是执行他的回调函数。而当异步任务到达某种程度时，或者回调函数使用不当时，就会形成所谓的回调地狱，回调函数里嵌套回调函数，一两层还好，但有时候业务逻辑的复杂，回调函数甚至可以达到 10 层以上。这里做一个简单的示范：1234567891011121314(() =&gt; { setTimeout(() =&gt; { console.log(\"第一层回调函数\"); setTimeout(() =&gt; { console.log(\"第二层回调函数\"); setTimeout(() =&gt; { console.log(\"第三层回调函数\"); setTimeout(() =&gt; { console.log(\"第四层回调函数\"); }, 2000); }, 2000); }, 2000); }, 2000); })();如上面这样写异步任务，就显得不够有优雅，不太易于寻常人类的阅读，形成所谓的回调地狱。Promise而 Promise 对象的出现，从某种程度上避免了回调地狱，可以更加优雅的来写异步的代码，不过并不是真正意义上的消灭回调函数，而是将其转换成一个又一个的 then() ，但聊胜于无，有更加优雅的方式总比没有好。总而言之，就是 Promise 对象提供统一的 API ，各种各样的异步任务够可以使用其提供的 API，采用同样的方法来编写代码，更加的优雅。最后在浏览器控制台中，console.dir() 一下 Promise 对象，看看它的庐山真面目，好在下文探究未完待续…","link":"/2018/09/25/ES6 Promise 对象/"},{"title":"JavaScript 中的几种函数声明方式小记录","text":"前言最近在学 JavaScript 对其的函数声明的几种方式有很大的兴趣, 思考了一些东西, 所以就写下这篇博客来记录, 可以说 函数是 JavaScript 中最有趣的东西了. 据说 Brendan Eich 在创造它时, 比较中意的是函数式, 但他当时的公司在于 sun 合作, 所以希望他把 JavaScript 整的像 Java 一点, 并取名为 JavaScript. 但与 Java 并没有什么关系. 在其风格上看, 个人认为更像是 C 风格的函数式脚本语言.在 JavaScript 中所有的一切都是对象, Object 是一个基础类型, 而 Function 类型是引用 Object 类型继承而来的, 函数作为 Function 类型的实例, 也是对象.众所周知, 在 JavaScript 中有三种方式来定义函数, 但其实是四种, 另一种是使用命名函数表达式来定义函数, 这种方式很少用到.第一种: 函数声明的方式来定义这种方式和其他语言也没多大区别, 和其他语言的形式一样, 使最常见的一种方式.其语法格式如下:123function 函数名(形参1, 形参2, ...) { //函数体} 例:123function add(num1, num2) { return num1 + num2;} 第二种: 函数表达式来定义其语法格式如下:123var 变量名 = function(形参1, 形参2, ...) { //函数体}; 例:123var add = function(num1, num2) { return num1 + num2;}; 这种方式需要在结尾加上一个分号, 因为我们相当于把一个函数赋给一个变量, 也就是相当于一条表达式语句. 并且在 function 后没有再跟函数名, 这种情况下所创建的函数又称匿名函数(拉达母函数). 通过赋给的这个变量名即可调用这个函数.关于函数声明和函数表达式的区别个人暂时认为主要有两种:解释器对二者的区别JavaScript有一个特性就是:变量声明和函数声明会被提前(hoist)到作用域的顶端，所以通过函数声明创建的函数，什么时候都可以被调用，但是通过函数表达式创建的函数，只能在创建时才能调用.","link":"/2018/04/25/JavaScript 中的几种函数声明方式小记录/"},{"title":"JavaScript 中的继承总结","text":"前言由于 JavaScript 并不是那些“传统意义上”的面向对象的语言， 它在 ES5 中并没有类的概念， 没有真正意义上的继承， 但我们去可以进行模拟， 来实现所谓的继承。在 JavaScript 中， 实现继承的过程中总感觉很有趣， 至少在 ES5 中是这样的， ES5 中自己亲自要通过原型链去实现继承， 而在 ES6 中则将这些需要自己写的封装成了一个接口， 其本质上还是一样， 都是通过原型链实现继承。基于原型链的继承JavaScript 中，原型对象的存在， 大体上有两个作用：一是实现资源共享， 二是实现继承。 说白了就是为了节省内存空间， 可以让其构造函数实例出来的对象实现资源共享。原型链实现继承的基本思路是：让“子类”的原型指向“父类”的实例对象， 这样就可以使用原型链来实现继承属性和方法。不多说，直接上代码：1234567891011121314151617181920212223242526// 父类---人类function Parson(name, sex, age) { this.name = name this.sex = sex this.age = age}Parson.prototype.eat = function () { console.log('吃嘛嘛香')}// 子类---学生function Student(score) { this.score = score}// 改变子类的原型指向，指向父类实例，实现继承Student.prototype = new Parson('小谭', '男', 18)// 子类自己的方法Sutdent.prototype.learning = function () { console.log('三更灯火五更鸡，正是男儿读书时')}var std = new Student(100)console.log(std.name, std.sex, std.age, std.score) // 小谭 男 18 100std.eat() // 吃嘛嘛香std.learning() // 三更灯火五更鸡，正是男儿读书时可以看到，“子类”改变原型的指向为父类的实例对象， 可以实现属性和方法的继承， 但这种有缺点， 就是继承的属性值会重复。借用构造函数实现继承借用构造函数实现继承， 就是在“子类”的构造函数中调用“父类”的构造函数， 借用 call() 或 apply() 方法在特定的环境内执行另一个函数。123456789101112131415161718192021222324252627282930// 父类---人类function Parson(name, sex, age) { this.name = name this.sex = sex this.age = age}Parson.prototype.eat = function () { console.log('吃嘛嘛香')}// 子类---学生function Student(name, sex, age, score) { // 借用父类的构造函数 Parson.call(this, name, sex, age) this.score = score}// 子类自己的方法Student.prototype.learning = function () { console.log('三更灯火五更鸡，正是男儿读书时')}var std1 = new Student('小谭', '男', 18, 100)var std2 = new Student('小林', '女', 20, 99)console.log(std1.name, std1.sex, std1.age, std1.score) // 小谭 男 18 100console.log(std2.name, std2.sex, std2.age, std2.score) // 小林 女 20 99std1.learning() // 三更灯火五更鸡，正是男儿读书时std2.learning() // 三更灯火五更鸡，正是男儿读书时std1.eat() // 报错！std2.eat() // 报错！借用构造函数来继承， 可以解决原型链继承的属性重复问题， 但又有新的问题， 就是不能继承“父类”的方法。组合继承就单单使用原型链继承，和借用构造函数继承， 我们不会单一的去使用， 更多的是将二者结合起来， 各发挥其优点， 也就是组合继承。 原型继承实现方法的继承， 借用构造函数实现对实例属性的继承， 最为经典的一种继承方法。1234567891011121314151617181920212223242526272829303132// 父类---人类function Parson(name, sex, age) { this.name = name this.sex = sex this.age = age}Parson.prototype.eat = function () { console.log('吃嘛嘛香')}// 子类---学生function Student(name, sex, age, score) { // 借用父类的构造函数 Parson.call(this, name, sex, age) this.score = score}// 改变子类原型指向父类实例Student.prototype = new Parson()// 子类自己的方法Student.prototype.learning = function () { console.log('三更灯火五更鸡，正是男儿读书时')}var std1 = new Student('小谭', '男', 18, 100)var std2 = new Student('小林', '女', 20, 99)console.log(std1.name, std1.sex, std1.age, std1.score) // 小谭 男 18 100console.log(std2.name, std2.sex, std2.age, std2.score) // 小林 女 20 99std1.learning() // 三更灯火五更鸡，正是男儿读书时std2.learning() // 三更灯火五更鸡，正是男儿读书时std1.eat() // 吃嘛嘛香std2.eat() // 吃嘛嘛香拷贝继承拷贝继承， 则是利用 for in 将父类原型对象中的方法， 依次复制给一个新的对象。 利用循环继承原型方法， 再利用 call() 方法实现对属性的继承。12345678910111213141516171819202122232425262728293031323334// 父类---人类function Parson(name, sex, age) { this.name = name this.sex = sex this.age = age}Parson.prototype.eat = function () { console.log('吃嘛嘛香')}// 子类---学生function Student(name, sex, age, score) { // 借用父类的构造函数 Parson.call(this, name, sex, age) this.score = score}// 遍历父类原型对象， 并拷贝给子类原型对象for (var key in Parson.prototype) { Student.prototype[key] = Parson.prototype[key]}// 子类自己的方法Student.prototype.learning = function () { console.log('三更灯火五更鸡，正是男儿读书时')}var std1 = new Student('小谭', '男', 18, 100)var std2 = new Student('小林', '女', 20, 99)console.log(std1.name, std1.sex, std1.age, std1.score) // 小谭 男 18 100console.log(std2.name, std2.sex, std2.age, std2.score) // 小林 女 20 99std1.learning() // 三更灯火五更鸡，正是男儿读书时std2.learning() // 三更灯火五更鸡，正是男儿读书时std1.eat() // 吃嘛嘛香std2.eat() // 吃嘛嘛香结语JavaScript 是基于原型的编程， 在 JavaScript 继承中， 原型贯穿着整个过程。 也由于原型的存在， 让 JavaScript 及其的灵活， 可以让我们实现一些面向对象的特征。 这几种继承的方式， 组合继承最为经典。","link":"/2018/06/15/JavaScript 中的继承总结/"},{"title":"Node.js + Express + mongodb 的博客项目之初始化项目及安装依赖文件（二）","text":"前言在这一节中，将会初始化项目，并安装相关依赖模块，同时启动第一个服务。这是一切的开始，后面所做的一切都是在这个基础上添砖加瓦。初始化项目创建一个项目目录如 node_blog ，并且在该目录下，使用 Node.js 包管理工具 npm 进行项目初始化1npm init安装相关模块使用以下代码安装相关的依赖模块，并写入 package.json 中1npm i express mongoose ejs moment marked cookies body-parser --save以上各个模块对应的用途是express：WEB 框架mongoose：mongodb 驱动ejs： 模板引擎moment：时间格式化marked：解析 Markdowncookies： 保持登录状态body-parser：解析 HTTP 请求体安装成功后会多出一个 node_modules 文件夹，用于存放相关模块创建相应的应用目录创建上一节中所设计的目录结构目录models：数据库模型文件目录public：公共文件目录（js,css等）routers：路由文件目录shcemas：数据库结构文件目录views：模板视图文件目录app.js：应用启动文件入口此时项目的目录结构如下编写 app.js 启动第一个服务在 app.js 中，写上如下代码1234567891011121314// 引入相关模块const express = require(&quot;express&quot;);// 实例化一个express对象let app = express();// 给app绑定路由，所有通过&quot;/&quot;的url都将通过以下方法app.get(&quot;/&quot;, (req, res, next) =&gt; { // 发送内容至客户端 res.send(&quot;&lt;h1&gt;TFL BLOG&lt;/h1&gt;&quot;);});// 监听8080端口app.listen(8080);然后在项目目录下运行 node app 项目，在浏览器中输入 http://localhost:8080/好了，到这里就做了一个开头，相当于地基，接下来就是往这个地基不断地添砖加瓦，完成我们所需要的功能。","link":"/2018/07/23/Node.js + Express + mongodb 的博客项目之初始化项目及安装依赖文件（二）/"},{"title":"Node.js + Express + mongodb 的博客项目之前言（一）","text":"前言学习 Node.js 也有一段时间了，整个过程断断续续的，在学习过程中感觉内心还有点浮躁，所以就准备写一个 Node.js 的实战系列，让自己静下心来，同时这个过程也不断的巩固自己之前所学的知识，之后也方便自己进行知识回顾。技术栈Node.jsNode.js 的出现是为了解决 WEB 服务器的高并发性能问题，慢慢演化成一门后端语言。ExpressExpress 是一个 Node.js 的 WEB 框架，封装了很多种方法，提高了我们的开发效率，可以设置中间件来响应 HTTP 请求。mongodbmongodb 是一个非关系型的数据库，轻量级的数据库，也就是集合型的，如同 json 的那般数据格式ejs 模板引擎模板引擎嘛，后端渲染数据，动态生成 html ，和以前学的 Java Web 中的 jsp 基本差不多。mongoosemongodb 的数据库驱动，里面封装了对数据库的各种基本操作，怎么省事怎么来jQuery省时省力的 DOM 操作Bootstrap响应式的 UI 库，便捷开发项目结构12345678910111213141516171819node_blog││ app.js // 入口文件││ package.json // 项目依赖配置文件││───models // 数据库的模型，提供相应的数库操作│ │───node_modules // 存放各种node模块和express框架││───my_modules // 自己编写的模块││———routes // 存放路由文件││———schemas // 数据库里要存储的数据结构│ │———public // 静态资源库，用于存放静态资源的│ └───views // 视图文件，也就是模板项目的设计模式远远比良好的数据结构和代码质量重要的多，看上面的项目结构，很明显的 MVC 标准结构，MVC 要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。博客功能及路由设计api.js –&gt; 提供相关接口POST /user/register 用户注册POST /user/login 用户登录GET /user/logout 用户登出admin.js –&gt; 博客后台路由GET / 后台首页GET /user 用户管理GET /category 文章分类管理界面GET /category/add 文章分类添加界面POST /category/add 文章分类添加的保存GET /category/edit 文章分类修改界面POST /category/edit 文章分类修改的保存GET /category/delete?id=xxx 文章分类删除GET /content 文章管理界面GET /content/edit 文章修改界面POST /content/edit 文章修改的保存GET /content/add 文章添加界面POST /content/add 文章添加的保存GET /content/delete?id=xxx 文章的删除index.js –&gt; 博客前台界面路由GET / 首页未完待续","link":"/2018/07/22/Node.js + Express + mongodb 的博客项目之前言（一）/"},{"title":"Node.js + Express + mongodb 的博客项目之博客内容的前台展示（八）","text":"前言前台内容的展示，是将博客的文章内容从数据库中查询出来，再将数据绑定给模板引擎，由模板引擎渲染出来。由于博客首页的数据是需要分页展示的所以就需要调用之前自己定义的的博客分页处理模块 /my_modules/pagination.js ，但在此之前得先将博客的文章分类信息从数据库中查询出来，在查询博客分类信息的回调函数中来调用 pagination.js 渲染内容。首页路由修改由前端使用 GET 方式向后端传递用户当前点击的文章分类的 ID ，后端根据文章分类 ID 的不同而从数据库中查询出相应的博客内容。修改首页的路由处理文件 /router/main/main.js ，修改为如下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 引入相关模块const express = require(\"express\");const categoryModel = require(\"../models/category\");const contentModel = require(\"../models/content\");// 引入自定义的分页渲染模块const pagination = require(\"../my_modules/pagination\");// 实例化Router对象const router = express.Router();// 首页路由配置router.get(\"/\", (req, res) =&gt; { // 定义一个变量用来存放传递给模板的其他信息 let other = {}; // 分类查询条件 let where = {}; // 接收前端传递过来的需要查询分类的id if (req.query.categoryId) { other.categoryId = req.query.categoryId; where.category = req.query.categoryId; } // 从数据库中查询分类信息 categoryModel.find({}, (err, categories) =&gt; { if (!err) { // 如果不出错 other.categories = categories; // 调用分页渲染模块渲染内容 pagination({ // 每页显示的条数 limit: 10, // 需要操作的数据库模型 model: contentModel, // 需要控制分页的url url: \"/\", // 渲染的模板页面 ejs: \"main/index\", // 查询的条件 where: where, // 给模板绑定参数的名称 res: res, req: req, populate: [\"category\", \"author\"], // 其他数据 other: other }); } else { throw err; } });});// 将其暴露给外部使用module.exports = router;博客首页模板视图的修改修改 /views/main/index.ejs 为如下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;TFLIN'BLOG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页头 --&gt; &lt;header&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;TFL'BLOG&lt;/a&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;% if (!other.categoryId) {%&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;% } else {%&gt; &lt;li&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;% } %&gt; &lt;% for (let i = 0, len = other.categories.length; i &lt; len; i++) {%&gt; &lt;% if (other.categoryId === other.categories[i].id) {%&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/?categoryId=&lt;%= other.categories[i].id %&gt;\"&gt;&lt;%= other.categories[i].name %&gt;&lt;/a&gt;&lt;/li&gt; &lt;% } else {%&gt; &lt;li&gt;&lt;a href=\"/?categoryId=&lt;%= other.categories[i].id %&gt;\"&gt;&lt;%= other.categories[i].name %&gt;&lt;/a&gt;&lt;/li&gt; &lt;% } %&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/header&gt; &lt;!-- 主体 --&gt; &lt;div class=\"container\"&gt; &lt;!-- 内容部分 --&gt; &lt;div class=\"col-md-8\"&gt; &lt;% for(let i = 0, len = docs.length; i &lt; len; i++) { %&gt; &lt;div class=\"well\"&gt; &lt;h3&gt;&lt;%=docs[i].title%&gt;&lt;/h3&gt; &lt;p&gt;&lt;%=docs[i].description%&gt;&lt;/p&gt; &lt;a href=\"javascript:;\" class=\"btn btn-info\"&gt;阅读全文&lt;/a&gt; &lt;span class=\"text-info pull-right\"&gt;阅读量：&lt;%=docs[i].views%&gt; | 时间：&lt;%=docs[i].addTime%&gt; | 作者:&lt;%=docs[i].author.username%&gt; | 分类:&lt;%=docs[i].category.name%&gt;&lt;/span&gt; &lt;/div&gt; &lt;% } %&gt; &lt;!-- 分页 --&gt; &lt;%- include(\"../pagination\") %&gt; &lt;/div&gt; &lt;!-- 登录、注册、用户面板部分 --&gt; &lt;div class=\"col-md-4\"&gt; &lt;%if (!userInfo.userid) {%&gt; &lt;!-- 登录面板 --&gt; &lt;div id=\"login\"&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"login-btn\"&gt;登录&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;没有账号？点击注册&lt;/a&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注册面板 --&gt; &lt;div id=\"reg\" class=\"hide\"&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户名称&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;输入密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;确认密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"repassword\" placeholder=\"请再次输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"reg-btn\"&gt;注册&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;已有账号？点击登录&lt;/a&gt; &lt;!-- 警告框 --&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;%} else {%&gt; &lt;!-- 用户面板 --&gt; &lt;div id=\"user-info\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt;用户面板&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;%if (userInfo.isadmin) {%&gt; &lt;h3&gt;欢迎尊贵的管理员，&lt;%=userInfo.username%&gt;!&lt;/h3&gt; &lt;p&gt; &lt;a href=\"/admin\" class=\"btn btn-primary form-control\"&gt;进入控制台&lt;/a&gt; &lt;/p&gt; &lt;%} else {%&gt; &lt;h3&gt;欢迎您，&lt;%=userInfo.username%&gt;！&lt;/h3&gt; &lt;%}%&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" id=\"logout\" class=\"btn btn-danger form-control\"&gt;注销&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%}%&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;测试在管理员控制台，多添加几篇不同分类的文章，然后返回博客首页进行测试","link":"/2018/08/05/Node.js + Express + mongodb 的博客项目之博客内容的前台展示（八）/"},{"title":"deepin 启用交换文件","text":"前言自己的电脑太渣了，刚上大学的时候买的，期间不断升级配件坚挺到现在。自大四上学期后就一直是双系统 win10 + deepin。平时娱乐和基友玩游戏就换回 win10，工作和学习都是在 deepin 上进行的。但由于电脑实在是太渣，而 vscode 和 chrome 又是吃内存大户，升级的 8G 内存实在是不够用，多开几个 vscode 和 chrome 再启动几个 node 服务 时间一久，就会报爆存，而 deepin 的内存管理又实在是差劲，一爆内存就彻底卡死。这个状况直到开启了 swap 文件后，就好了很多，系统再也不会爆内存卡死了，但非固态硬盘不推荐开启 linux 交换文件。过程1.创建一个足够大的文件，linux 中一切皆文件，用此文件当做交换空间1sudo dd if=/dev/zero of=/root/swapfile bs=1M count=8192(count 的值等于 1024 x 你想要的文件大小，8192 是 8G，该文件的大小建议与物理内存一致)2.把这个文件变成 swap 文件.1sudo mkswap /root/swapfile3.启用这个 swap 文件1sudo swapon /root/swapfile4.在每次开机的时候自动加载 swap 文件, 需要在 /etc/fstab 文件中增加一行1echo \"/root/swapfile swap swap defaults 0 0\" | sudo tee -a /etc/fstab5.查看 swap1cat /proc/swaps最后最后效果还是非常显著的，物理内存快占满的时候，就会将刚才创建的交换文件当做交换空间，用硬盘当做内存，这样系统就不会因为爆内存而卡死，自己也能愉快的开发了。至于关闭交换文件，则可以使用 swapoff 命令，然后删除文件即可。","link":"/2019/12/16/deepin 启用交换文件/"},{"title":"Node.js + Express + mongodb 的博客项目之评论系统（十）","text":"前言本节内容主要是构建一个对博客文章的评论功能，由前端使用 ajax 通过 GET 方式向 /api/comment/post 路由提交评论，服务器再将其保存在数据库中。当用户没有登录时，会提示用户没有登录，不能评论。用户登陆以后，会显示一个评论文本框，用来给用户提交评论，提交后的评论会使用 ajax 进行局部刷新在博客文章的下方显示出来。提交的时候，会在前端进行简单的验证吗，验证通过后才能提交评论，否则 return false。评论的前端界面评论的界面，使用模板引擎的条件判断来根据当前用户是否登录来显示不同的界面，也就是使用前面 cookie 的信息来进行判断，若 userInfo.userid 存在则显示评论界面，反之提示未登录。为方便 ajax 获取需要向后端传送的文章 ID ，在这里将文章的 ID 设为一个隐藏的 input 的属性。在 /views/main/views.ejs 中，在文章内容部分 (&lt;%- contentHtml %&gt;) 后，添加上如下代码：123456789101112131415161718192021&lt;div class=\"text-muted text-center\"&gt;------------本文结束------------&lt;/div&gt; &lt;!-- 评论 --&gt; &lt;div class=\"well\"&gt; &lt;input type=\"hidden\" id=\"contentId\" value=\"&lt;%= content.id %&gt;\"&gt; &lt;% if (userInfo.userid) {%&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;说点什么&lt;/label&gt; &lt;textarea class=\"form-control\" rows=\"3\" cols=\"4\" placeholder=\"输入评论\" id=\"comment\"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;button class=\"form-control btn btn-primary\" id=\"comment-btn\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;% } else { %&gt; &lt;div class=\"alert alert-danger\"&gt;请先登录！&lt;/div&gt; &lt;% } %&gt; &lt;div class=\"commentList\"&gt; &lt;div&gt; &lt;span&gt;作者 | 时间&lt;/span&gt; &lt;p&gt;评论内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;数据库中的评论存储处理为了方便，我暂时仅将博客的评论新增为文章集合的一个属性，并未新设一个集合。修改 /schemas/contents.js 文件，将博客文章的存储格式新增一个名为 comment 字段，类型为数组，默认为空数组。1234comment: { type: Array, default: [] }如此一来，博客文章的评论的数据库储存格式也暂时完成。后端 api 处理后端关于评论处理的接口主要有两个，一个是提交评论，另一个是读取评论。提交评论是由前端使用 ajax 通过 POST 的方式向服务器提交评论的用户和评论的内容，再由服务器进行相应的格式化处理后存入数据库中。而获取评论同样也是前端使用户 ajax 通过 GET 的方式向服务器提交需要获取评论的文章 ID ，再有服务器将该文章的所有评论从数据库中读取出来后传送给前端，由 ajax 局部刷新加载出来。在 /routes/api.js 中，添加如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取评论的接口router.get(\"/comment\", (req, res) =&gt; { // 获取提交的信息 let contentId = req.query.contentId || \"\"; // 根据id查询文章信息 contentModel.findById(contentId, (err, content) =&gt; { if (!err) { // 向客户端发送当前评论 res.json(content.comment); return; } else { throw err; return; } });});// 提交评论的接口router.post(\"/comment/post\", (req, res) =&gt; { // 获取提交的信息 let contentId = req.body.contentId; let comment = req.body.comment; // 构建评论结构 let commentData = { username: req.userInfo.username, postTime: new Date(), content: comment } // 根据文章id将文章查询出来 contentModel.findById(contentId, (err, content) =&gt; { if (!err) { // 如果文章存在则将评论推入 content.comment.push(commentData); // 保存 content.save(); // 向客户端发送当前评论 res.json(content); return; } else { throw err; return; } });});前端 ajax 处理在 /public/js 文件夹中，新建一个 comment.js 文件用来处理评论相关的 ajax。内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$(() =&gt; { // 提交评论 (() =&gt; { // 获取提交按钮 $subBtn = $(\"#comment-btn\"); // 获取评论内容 $comment = $(\"#comment\"); // ajax请求 $subBtn.on(\"click\", () =&gt; { // 简单验证 if ($comment.val() === \"\") { alert(\"评论内容不能为空\"); return; } $.ajax({ type: \"post\", url: \"/api/comment/post\", data: { contentId: $(\"#contentId\").val(), comment: $comment.val() }, dataType: \"json\", success: (result) =&gt; { // 调用渲染评论函数 renderComment(); $comment.val(\"\") } }); }); })(); // 渲染评论的函数 renderComment = () =&gt; { // ajax请求 $.ajax({ type: \"get\", url: \"/api/comment/\", data: { contentId: $(\"#contentId\").val(), }, dataType: \"json\", success: (result) =&gt; { // 创建html结构 let commentList = \"\"; for (let i = result.length - 1; i &gt;= 0; i--) { // 格式化时间 let postTime = commentList += ` &lt;div&gt; &lt;span&gt;用户：${ result[i].username } | 时间：${ result[i].postTime }&lt;/span&gt; &lt;p&gt;${ result[i].content }&lt;/p&gt; &lt;/div&gt; ` } // 添加进入html文档中 $(\".commentList\").html(commentList); } }); } // 调用渲染评论函数 renderComment();});测试最后再重启服务器，刷新客户端进行测试","link":"/2018/08/17/Node.js + Express + mongodb 的博客项目之评论系统（十）/"},{"title":"乐评：林俊杰-我们(live)","text":"有时间写乐评，竟然不把以前的坑补上？没办法，这场表演，实在是太有感触了。在这个“连伤感都是奢侈”的娱乐至死的大背景下，谢谢你这一场一生一次忠于自己的表演。待更…","link":"/2018/11/18/乐评：林俊杰-我们(live)/"},{"title":"从 JavaScript 看函数式编程之美","text":"先占个坑，这阵子实习，忙着忙着项目的混合app开发，有空再更……","link":"/2018/10/31/从 JavaScript 看函数式编程之美/"},{"title":"Node.js + Express + mongodb 的博客项目之总结（十一）","text":"前言之前一直想做一个前后端都完整的个人项目，但由于当时还在学校进行实训2的学习，就一直没有多少时间着手，所以就在暑假的时候将这个项目做了起来。技术栈上采用 Node.js + Express + mongodb，经过了断断续续的开发，如今完成了这个项目的大部分基本功能，今天抽个时间写了个总结。项目的代码我全程托管到 GitHub 上，项目地址 https://github.com/tflins/node_blog难点将过程整理成博客整个项目，最耗费我时间的，不是写代码开发的过程，而是我将其过程整理成博客文章。有时候真的有种说不出的感觉，在写博客的过程中，你需要咬文爵字，思考着怎么样来写，怎么样来描述这个过程，什么东西是需要重点提及的，什么东西是需要一笔带过的······ 这些东西都需要自己去思考，去琢磨，所以说写博客真的很锻炼人(笑哭)。Node.js 的异步处理整个开发过程，我印象最深的就是 Node.js 的层层回调了（传说中的回调地狱）。最主要的是体会到了异步开发的思想，不要尝试使用同步的思维去写 Node.js，当然也可以，但会影响性能。就比如 mongooes 模块所提供的数据库驱动，它并没有提供相关的同步方法，全是异步方法。如果使用同步的思维去写异步，就会出现你在某些地方需要 I/O 操作返回的值的时候，得不到需要的值，因为它会将 I/O 操作放在执行队列的后面。所以，就需要不断的使用回调函数，一个两个三个还好，但随着功能需求的增加，就会形成传说中的回调地狱。所以，为了追求更加优雅的代码，异步处理也有不同的写法，在本项目中，最常用的是 ES2016 中的 promise。app.use本项目所采用的 WEB 框架 Express 中，最常用的就是 app.use() 了。app.use 的官方文档原文是：Mounts the specified middleware function or functions at the specified path: the middleware function is executed when the base of the requested path matches path. 大概意思就是就是把特定的中间件加载到特定的请求路径下面。当一个请求来的时候，会依次被这些中间件处理，app.use顺序执行，使用 next() 继续。app.use注册的中间件，如果path参数为空，则默认为”/”，而path为”/”的中间件默认匹配所有的请求。cookie 的使用在需要保持用户登录的时候就需要 cookie 了，在我的另一篇博客里面介绍有关于 cookie 在本项目中的使用 –&gt; Node.js + Express + mongodb 的博客项目之保持用户登录，区分管理员账户，及用户登出（四）。分页模块的封装在这个项目中，需要多次用到分页查询数据的功能，所以我就将他给封装成一个模块，以便多次使用。但在这过程中却是略微痛苦的，因为有时候不同的页面它所需要的分页数据是不同的，所以我就得不断的完善分页处理模块的参数及方法，以实现不同的需求，参数一多，我就觉得不够优雅，所以就以对象的形式作为参数传递过去。结语整个过程真的是挺锻炼人的，学习的时候，不断的输入新的知识，然后将学到的知识转换成自己的再以另一种形式输出出去。就比如，我将自己所学的，整理成相应的博客。这样一来，就有了所谓的 输入 –&gt; 输出 的学习模式，很不错。话也不多说了，准大四了，希望未来的自己能有更好的发展吧！","link":"/2018/08/19/Node.js + Express + mongodb 的博客项目之总结（十一）/"},{"title":"前端实习的那些日子","text":"闲言碎语不得不感叹时间真的是飞逝，如今都9102年了，还有几个月自己就步入社会大学了。自2月25号提交离职申请，不知不觉已经实习近4个月了。如今回校，就想写点什么，记录下，总结下，沉淀下自己。时间回到2018年10月7号，自己一个人拖着沉重的行李箱来到成都，先跟公司的hr小姐姐联系了下，取得员工宿舍的地址后，便往宿舍的地址奔去。给我开门的，是一个高瘦的小伙子，好奇的盯了我两眼，我说明来意后，由于我不抽烟，他便安排我住进了他们那间房间。进入房间后发现还有另外一个小伙子，蹲在一张小板凳旁吃外卖。交谈后得知，他是一个 python 实习生。而给我开门的那个高瘦小伙子不是实习生，是工作了一年的正式员工python的。8号，跟着宿舍几个小伙伴一起前往公司，到两江国际楼下的时候，看着忙碌的等着电梯，打着卡的人群，突然有点恍惚，这或许就是我以后生活的写照。来到公司的第一天，办了入职手续后，领了一台小米笔记本。公司成都研发部目前两个项目组，我被安排到了其中一个项目组。来公司的第一天，项目组的 leader 便安排了一场会议，自我介绍完毕后便开始学习公司的相关规范及业务流程。也给我安排了一个师傅h姐带我。一个刚走出校门出去实习的大学生，对一切总是充满好奇，对着导师h姐东问问，西问问，而她也不厌其烦的一一为我解答。第二天，便开始装公司的开发环境了，我所在的这个项目组，由于历史遗留问题，前后端并没有进行分离，前端开发十分的依赖着 java 的环境。前端也没有进行工程化开发，使用 jQuery 技术栈，处于前端农耕时代。这一天，依旧阅读着项目的代码，熟悉各个模块。第三天，觉得自己熟悉的差不多了。便给前端的组长s姐发了个钉钉，问她要了一个 ticket。s姐便给我分配了一个修复缺陷的 ticket。开始s姐给我的缺陷也不难，很快就修复好了。就这样，前两周就在修复缺陷中度过。到了第二周的时候，公司的项目要衍生出一个混合 App ，于是我就被分配到了另一个人的手下，d姐手下。d姐是一个 java 工程师，我到的时候她已经把技术栈给选好了，并已完成了登录及部分功能。也就是采用 MUI 作为基本框架，使用 Hbuilder 进行打包。就这样，一个 java ，一个前端就开始了混合 App 的开发。d姐负责写接口，而我则负责还原 UI 稿及根据接口开发前端功能。混合 App 的开发到一个多月的时候，大部分功能就已经实现了。这个时候，第一个版本就已经出来了，交付给测试进行时间为一周的集中测试，之后自己则继续修改自己开发出来的混合 App 的缺陷。当混合 App 的缺陷修复的差不多后，自己又被调回 WEB 端的项目里面进行缺陷的修复。在这期间，自己又对几个模块进行了重构，这段时间几乎是整个实习生涯最忙的时候，有时候自己回到宿舍后，依旧要写代码到凌晨。之后的时间，公司项目便有了新的需求提出来。自己也跟着参与了需求评审，进行了一番讨论后，便开始跟着开发新的功能，而我负责实现各个弹窗的功能并封装起来，以便各个模块的调用。就这样，不知不觉4个月了。而自己也在这期间思考了很多东西，结合自身的各种情况，于是决定辞职。公司的同事都很好，但人各有志。真的是，这一别，不知何年才能在相遇，若相遇，希望是在什么什么前端大会上，或是其他技术交流的会议上，共同进步。收获总结前面啰嗦了一堆，该说说实习期间的收获了。首先，最大的收获莫过于协同开发了。虽然自己的版本控制(GIT)是自带的，但之前都是自己一个人，一条线的进行开发，就好似 JavaScript 的单线程一般。自己的代码，怎么写，都不会产生冲突，就算冲突了，删了便是。而真正的开发中，是不可能这样做的，多个人，一起进行一个项目的开发，并发执行，当代码产生冲突的时候，就需要去与写冲突代码的人进行沟通，探讨原因，协商处理等。还有就是，自己写完的功能，要及时提交代码，因为如果自己不及时提交的话，可能会造成阻塞，或者别人该缺陷的时候，改到了你负责的这个模块，就有可能造成代码冲突。其次，便是自己沟通能力的提升。作为一名前端，就要经常性的跟后端进行沟通。开发混合APP的时候，数据来源都是源自后端提供的 API ，所以自己经常要去找d姐商量数据结构，及需要提供的相关接口。然后，是搜索信息能力的提升。接着，debug能力的提升。最后，JavaScript 的巩固。总结未完待续……","link":"/2019/03/12/前端实习的那些日子/"},{"title":"使用 GitLab CI 进行持续集成的一些踩坑","text":"前言最近重新使用 GitLab CI 对项目进行持续集成，碰到了一些问题，在此记录下来，并给出自己的解决方案，或许可以给搜到这的朋友一些帮助或启发。GitLab CI关于 gitlib ci 的介绍和基础知识 参考 用 GitLab CI 进行持续集成注册 runner 后，gitlab runner 出现灰色感叹号在服务器注册完 runner 后，在 gitlab 的 runner 处出现灰色感叹号，并提示 new runner has not connected yet。这个问题一般都是权限问题造成的，加 sudo 和不加 sudo 所创建的配置文件不同。在使用 gitlab-runner register 注册的时候，加上 sudo，在启动 runner 时也要加上 sudo ， sudo gitlab-runner restart 或 sudo gitlab-runner start 。无法删除 runner在使用 gitlab-runner unregister 删除 runner 时，提示 Error: unregistering runner from gitlab forbidden。使用 gitlab-runner verify 检测 runner 是否已连接至 gitlab ，然后 gitlab-runner verify --delete 在注册列表中删除它们。gitlab-runner list 不显示注册的 runner使用 sudo 权限注册的 runner 要使用 sudo gitlab-runner list 查看。构建时提示 mkdir: cannot create directop ‘/home/gitlab-runner/builds/xxxxx’: Permission denied用户 gitlab-runner 没有构建目录的权限，加上权限即可，或切换至 root 用户，给该文件夹上权限。构建时的环境变量问题如在构建的时候，提示 bash: npm: command not found，此时可以去服务器上给 bash 加上环境变量，或者在 before_script 阶段加上环境变量，例如：12before_script: - export PATH=/home/souche/n/bin:$PATH下一个 Stages 无法使用上一个 Stages 生成的文件这是因为在进行一个新的 Stages 时，会把上一个 Stages 所产生的文件删除掉，解决方案就是使用缓存 cache，如：1234cache: key: '$CI_COMMIT_REF_NAME' paths: - .nuxt构建时在 Getting source from Git repository 阶段出现错误提示 error: failed to write new configuration file /home/gitlab-runner/builds/xxxx/0/xxxx/xxxx.tmp/git-template/config.lock出现这个提示，请检查服务器磁盘是不是已经满了，请释放些磁盘空间构建过程出现 fatal: git fetch-pack: expected shallow list fatal: The remote end hung up unexpectedly这是因为服务器 git 版本太低，不支持新的 api，去服务器升级一下 git 版本","link":"/2020/04/10/使用 GitLab CI 进行持续集成的一些踩坑/"},{"title":"关于 Vue2.0 的生命周期","text":"前言Vue实例从创建开始到结束销毁的一系列过程，在这个过程中会有特定阶段的钩子函数，这些钩子函数会在 Vue 的各个状态中执行。总体上分为 8 个阶段：创建前/创建后；挂载前/挂载后；更新前/更新后；销毁前/销毁后。详细钩子函数说明beforeCreate()在Vue实例完全被创建出来之前执行的钩子函数，此时 data，methods 中的数据未绑定到 vue 实例中created()该钩子函数执行的时候，data 和 methods 中的属性和方法已经绑定到了 Vue 实例中，但 Dom 还未生成beforeMount()这个钩子函数表示虚拟 Dom 已经渲染完毕，但尚未把其渲染到页面中，仅仅在内存中渲染成虚拟 Dommounted()此时，虚拟 Dom 已经挂载(渲染)到页面中，虚拟 Dom 变成真实的 DombeforeUpdated()实例更新之前，也就是响应式数据更新的时候调用，在虚拟 Dom 打补丁之前updated()实例更新之后，在虚拟 Dom 重新渲染和打补丁之后调用beforeDestroy()实例销毁前调用，但在这一步中，实例任然完全可用，this 仍获取到实例，这是最后的机会destroyed()实例销毁后调用，最后什么都没了深入首先放一张官方的生命周期的图接下来，就从这张图慢慢的讲起首先，我们 new 一个 vue 实例出来之后，刚刚初始化完成之后调用 beforeCreated 这个钩子函数，实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import Vue from 'vue'const vm = new Vue({ el: '#app', data: { message: '早知如此绊人心，何如当初莫相识。' }, methods: { getMessage() { return this.message; }, changeMessage() { this.message = '入我相思门，知我相思苦。' } }, components: { changeButton: { template: ` &lt;button&gt;改变message&lt;button/&gt; ` } }, beforeCreate() { console.group('beforeCreate 创建前 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }, created() { console.group('created 创建后 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }, beforeMount() { console.group('beforeMount 挂载前 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log(this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }, mounted() { console.group('mounted 挂载后 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log(this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }, beforeUpdate() { console.group('beforeUpdate 更新前 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log(this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }, updated() { console.group('update 更新后 ====&gt;'); console.log('%c%s', 'color: red', 'el :' + this.$el); console.log(this.$el); console.log('%c%s', 'color: red', 'message :' + this.message); console.log('%c%s', 'color: red', 'getMessage() :' + this.getMessage()); }})待更…","link":"/2018/11/16/关于 Vue2.0 的生命周期/"},{"title":"关于 HTML5 中 CSS 设置 Canvas 画布的大小所遇到的问题","text":"前言在学习 HTML5 的 Canvas 标签时， 看了文档后， 自己写了一下， 发现遇到了一个问题。当我想改变画布的的大小的时候， 通常想到的是通过 CSS 样式来改变， 如：12345678910111213141516171819&lt;style&gt; #test-canvas { width: 300px; height: 300px; background-color: #ccc; }&lt;/style&gt;&lt;canvas id=\"test-canvas\"&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById(\"test-canvas\"); // 拿到CanvasRenderingContext2D对象 var ctx = canvas.getContext(\"2d\"); // 绘制一个边长为100像素的张方形 ctx.strokeRect(0, 0, 100, 100);&lt;/script&gt;但是结果始料不及！！！绘制出来是这样的：上面所绘制的明显不是一个正方形， 而是一个矩形。本着一名当代大学生的探索精神，由果溯因。首先我想到的是 document.getElementById(“test-canvas”) 所获取到的是一个对象， 那么这个对象里面有什么呢？于是 console.dir() 了一下12var canvas = document.getElementById(\"test-canvas\");console.dir(canvas);然后发现该对象中的两个属性也就是说 Canvas 的画布大小是 300 x 150, 而我自己定义的 CSS 样式大小是 300 x 300， Canvas 所绘制的图形会被拉伸。于是我又测量了一下：发现 Canvas 绘制的边长为 100 的正方形被拉伸到 100 x 200。 而之前 CSS 里面设定是 300 x 300, Canvas 画布默认大小为 300 x 150, 两者之间的高宽比就是 2 : 1, 所以正方形的高度被拉伸至 100 x 2 = 200， 宽度被拉伸至 100 x 1 = 100， 于是便有了上面那个 100 x 200 的矩形。那么也就是说 CSS 里面设置画布大小， 会导致画布按设定的值按比例缩放拉伸， CSS 里所设的大小只是设置画布在屏幕上显示的大小也就是说， CSS 里面设置的不是画布真实的大小， 所以要设置 Canvas 画布的大小， 那只有在 HTML 属性中， 或是使用 JavaScript DOM 操作进行设置。设置 HTML 属性：12345678910111213141516&lt;style&gt; #test-canvas { background-color: #ccc; } &lt;/style&gt;&lt;!--设置HTML属性--&gt;&lt;canvas id=\"test-canvas\" width=\"300\" height=\"300\"&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById(\"test-canvas\"); // 拿到CanvasRenderingContext2D对象 var ctx = canvas.getContext(\"2d\"); // 绘制一个边长为100像素的张方形 ctx.strokeRect(0, 0, 100, 100);&lt;/script&gt;JavaScript 设置：1234567var canvas = document.getElementById(\"test-canvas\");// 设置其对象属性canvas.width = 200;canvas.height = 200;// 拿到CanvasRenderingContext2D对象var ctx = canvas.getContext(\"2d\");ctx.strokeRect(0, 0, 100, 100);注： 以上所用截图工具， 屏幕尺子在我以前写的博客 我所收集的 Windows 系统下的神器 中的截图工具， 很强大！","link":"/2018/05/14/关于HTML5 中 CSS 设置 Canvas 画布大小所遇到的问题/"},{"title":"惨痛的教训","text":"这次我用 github 的静态库加上 hexo 重新搭建了一个博客。以前用的那个博客 (TFLIN.TOP) 是基于虚拟云主机 + Wordpress 搭建的。空间是在淘宝上的一个上的一个小空间商上买的，不贵，很便宜。域名也是在那家小公司买的，在解析的过程中，由于他们使用的解析系统太落后，很遇到了一些不可预料的麻烦。我想说的是，以后千万不要贪图小便宜，去选择一些不知名的小空间商，因为他们什么时候跑路你都不知道，我之前的那么博客所有的数据都没有备份，然后有一天我发现空间不能访问了，ftp服务器也凉了，是的没错！他们跑路了！跑路了！路了！了！让人猝不及防。","link":"/2018/03/04/惨痛的教训/"},{"title":"大四学习计划","text":"前言我并不是经常写计划的人，只是今天看着大一新生大包小包的进入校门，才意识自已经是半只脚踏出校门的老学长了。每次看着新生入学，都有一种奇妙的感觉，或许这就是焦虑的感觉。焦虑源于自己对未来的不安，而之所以感到不安，是因为自己不了解，自己无法掌控。但凡到了写计划的时候，通常都是自己觉得非要做出改变不可的时候。在知乎上看到别人的一个回答说：晚睡，是一个等待疲劳掩盖焦虑的过程。而自己也有晚睡的习惯，以后自己也会尽量避免晚睡的情况。毕竟，晚睡的危害，第二天就能体会到，更何况长时间的熬夜晚睡。关于前端在没真正意义上学前端之前，自己一直在学嵌入式相关的开发，那时候觉得前端没什么难的，不过是做网页而已。这种思想直到大三下学期时，学校开始专业实训2（必修）。实训2有两种情况可以选择，一种是学校老师自己开的实训，还有一种是学校跟外边公司合作开设的实训。学校自己的实训只有两个方向，而且是在学期末才开始的，持续6周。而和外边公司合作的实训则有很多个方向可以选择，是学期初就开始大约持续 4 个月，不过要交钱。开始就没打算跟着学校自己的实训走，所以就选择了学校与外边公司的实训。当时就想反正计算机主要是靠自学的，就报了一个比较便宜的方向 —- 前端 （笑哭），学校给补助了 2000，还得交 3000 块钱。就这样，我开始真正意义上的前端学习。开始，我就买了两本很多人都推荐的书：前端红宝石《JavaScript 高级教程》，还有张鑫旭大佬的《CSS 世界》。一边跟着外边公司的老师学习，一边慢慢的啃书，白天看纸质书，到了晚上就拿着 ipad 看电子版的书。吐槽一下：这个老师是做 Java 相关工作的，没想到被派来教我们前端，JavaScript 教得挺水的，没有深入，原型对象、继承、闭包等都都没有讲。自己在啃书的同时也在掘金，知乎等关注各种前端话题。随着自己对前端学习的深入感觉前端的学习曲线是这样的：先平缓，再陡峭，再接着平缓。刚开始确实觉得前端简单，做做界面，操作操作 DOM。可后来发觉前端不止如此，各种框架，移动开发，业务逻辑的复杂多变，前端工程化，组件化开发等，各种前端技术层出不穷。但最后再想想，大部分也终究脱离不了浏览器这个限制。原生 JavaScript不管学习任何的框架，万变不离其中，都需要扎实的 JavaScript 功底，自己会继续巩固自己的 JavaScript 基础，不管是 ES5 或是 ES6+。Vue.js、Node.js对外一直声称自己最近在学 Vue.js ，可这个最近到底要到什么时候！！！赶紧系统的学一遍，官方文档，各路大神的博客，再做做实践项目。Node.js 自然不用说，构建前端工程的必备工具。自己之前虽然学了挺久，常用模块都走了一遍，也使用 Express 框架写过一个项目 —- Node.js + express + mongodb 博客系统。但这远远不够，继续深入学习。前端工程化WEB 业务的日渐复杂，前端工程化是前端架构必不可少的一环，现在的自己对这一部分了解甚少，非学不可。数据可视化最近数据可视化大火啊，用自己写的爬虫爬来的数据，再利用前端工具进行数据可视化展示，想想都激动。PythonPython 没什么可说的，老伙伴了，继续学习，始终对它有一种特殊的感情。计网、算法计网和数据结构感觉大部分内容都还给老师了，而之前图书馆借的《算法导论》也没好好的翻上几次。得好好再学习这些东西了，对了，还有操作系统，这些都是一个 CS 专业必不可少的内功。好了，就这些，感觉自己写得有点啰嗦了。最后鸡汤收尾：最好的计划就是每天早上醒来就知道要做什么，晚上躺下就知道自己还有什么没做。","link":"/2018/09/08/大四学习计划/"},{"title":"我所收集的 Windows 下的神器","text":"解压工具首选 Bandzip其次 7-zip其他皆不尽人意图像查看器首选 Honeyview其次 MassiGraPDF阅读器Foxit Reader 功能强大Sumatra PDF 轻量级PDF阅读器录屏软件EV录屏 神器录出来的视频体积极小, 谁用谁知道视频播放软件potplayer 用过它以后, 我就再也没有用过其它的了桌面管理软件Fences 可以把桌面分区卸载工具geek 密码: ei4c 除了卸载无它功能, 效率字体软件字由 只有2.2M的压缩包大小，却提供了近千款的字体选择，另外也支持建立个人的字库。字由最大的特点在不用下载安装字体，应用字体之后即可直接在PS/AI/Office里使用文件搜索神器Everything 使用Everything来检索就特别方便了，主要是快，通常一两秒钟就可以检索出我们想要的文件。批量重命名ReNamer 密码: hdg2 专业的文件批量重命名，规则强大ORC识别天若ORC 密码: 2yke 天若ORC 直取屏幕上的信息，带翻译截图工具FSCapture 密码: dfv5 强大的截图工具，可制gif，有了它何须打开QQ截图","link":"/2018/04/18/我所收集的 Windows 系统下的神器/"},{"title":"实训一（嵌入式基础）个人总结","text":"时间过得真的是快，为时二十天的专业实训一随着此篇的完结，也落下了帷幕。二十天，看似很短的时间，但却能学到很多东西，走进实验室，跟随着老师的步伐，一步步，自己也跟着操作，期间不断总结，确实是挺好的学习方式。每天早上 8:30 到 11:30，再从中午 14:30 到 17:30，也就是每天 6 个小时。20 天，总共 120 个小时的针对性学习，让自己的嵌入式大概勉强算得上是初窥门栏了吧。2017年12月18日，踏进了实验室开启了实训一的序章。我们CS专业的不同于学院其他专业，因为我们相较于软工之流，我们学过了《模电》，《组成原理》及《操作系统》，所以对硬件底层有一定的了解。因此学院有意让我们往硬件上的方向走，请了华清远见的老师们来对我们进行培训。整个实训分两个阶段，第一阶段是：对C语言进行较为详细的讲解。第二阶段则是：入手开发板进行相应的学习。华清远见的老师讲得确实很好，条理清晰，同学们的思想也全都在线，并没有神游太空。第一阶段的学习是刘宗鑫老师带我们学习，第一天主要讲的是C语言的基本概念及Linux相关操作，这些都比较简单，而且之前我们也有学过所以并没有什么困难卡点，一马平川。但是到了学习指针的时候，不似前边那么顺利，指针是C语言的精华所在。为什么都说指针是C的精华所在呢？其实对此我也有自己的理解，简单来说，因为C就那点破feature，如果你把指针干掉，那这语言就完了。相反，如果你干掉struct，干掉union，干掉数组，甚至你把if-while都干掉，留下malloc和goto，则最多就是程序难写一点而已。所以这就是为什么C语言的精髓是指针了，因为他只有指针可以用了。C 语言只有值的传递，无法直接传递引用，要想传递引用必须通过指针间接实现。在实训期间，老师也别开生面的给我们讲解了指针，但这种东西真不是听着就能理解的，看同学们的状态便知，指针这种东西，唯有多用才明白，孰能生巧。自己亲自去使用它，才能理解它。等实训到第七天的时候，刘宗鑫老师开始讲解C语言网络编程，顺带我们复习了一下当初《计算机网络》所学习的内容，让自己的理解更加的深刻，使之能融会贯通。而此时，专业实训一的第一阶段马上就要结束了，老师带领我们开始做一个项目：基于LIUNX的网络聊天室。这个项目把我们前七天所学习的内容都综合起来，让我们各自加深对专业知识的了解，间中这个项目涉及到了TCP网络编程，这项一直是我不太熟悉的地方，借此项目，我查缺补漏，有把之前《计算机网络》上所遗忘的内容给回想起来了。第九天，这个时候银川早已一片白，一连下了好几天的鹅毛大雪。而我们也步入了第二阶段的学习，也就是在前一阶段的基础上上手开发板进行学习，带领我们学习的是安东老师。所涉及到的开发板是华清远见自己研发的FS4412开发板，FS4412采用的处理器使用Samsung的Exynos4412,性能很强大，当年盖世兔好像就是采用这个CPU，用来学习，绰绰有余。第二阶段的学习，主要是了解了一个过程，一个嵌入式产品从无到有的一个过程，不可谓收获不大。","link":"/2018/03/10/实训一（嵌入式基础）个人总结/"},{"title":"浅谈 100vh 在移动端中的差异及解决方案","text":"前言在做活动页的时候，第一页需要整屏显示，使用了 100vh 来作为第一页的高度，但在 ios safari 中效果却不是我所期望的那样。遂写篇博文来记录下问题的产生和解决及原因。存在的差异首先 100vh 在 Chrome 中模拟手机视图是正常的，如下：在安卓真机 UC Turbo 显示也是正常的：但在 ios safari 中，底部被 safari 的菜单栏挡住了：出现的原因这个问题出现的原因是：Safari 故意这样设计的，为此还专门做了很多的处理，因为它可以防止出现一些其他的问题。具体参见 Benjamin Poulain 回答的 bug 清单 ，其大意是：Safari 在滚动时可视高度会动态变化，如果在滚动的过程中更新 css 的视口高度，则会在滚动的过程中触发重新布局，这样做的话是非常糟糕的。Safari 在向下滚动的过程中，顶部的工具栏和底部的菜单栏会隐藏，这样一来页面的视口高度就会发生改变。此时 safari 有两个选择：第一个是在视口高度变化时动态的更新 css 的视口高度，但这样做页面会在高度变化的时候重绘回流，重新布局，不仅会影响滚动的性能，还会影响交互体验。第二个则是在变化前的小视口和变化后的大视口来做为一个统一的视口，显然 Safari 的开发人员选择了大的视口作为标准视口，这样就会出现上面提到的问题：css 中设置高度为 100vh 时，底部的菜单栏会挡住一部分页面，但却避免了更多的问题。解决方案对于上面的这个问题，目前来说，比较完美的方案就是利用 window.innerHeight 在 resize 事件中动态的设置高度，对于使用 vh 来说，可以使用 window.innerHeight 配合 css 的自定义属性（变量）来适配。如在 vue 中：12345678910111213141516mounted() { this.vhCheck() window.addEventListener('resize', this.vhCheck) this.$once('hook:beforeDestroy', () =&gt; { window.removeEventListener('resize', this.vhCheck) })},methods: { vhCheck() { // 模拟 vh let vh = window.innerHeight * 0.01 // 设置 css 自定义属性 document.documentElement.style.setProperty('--vh', `${vh}px`) }}这样一来，在 css 中便可以这样写：12345.page { /* 对不支持 css var 的浏览器做降级处理 */ height: 100vh; height: calc(var(--vh, 1vh) * 100);}使用第三方库推荐一个解决类似问题的 npm 库 vh-check1npm install vh-checkmain.js:123import vhCheck from 'vh-check'vhCheck('browser-address-bar')css:1234.page { height: 100vh; height: calc(100vh - var(--browser-address-bar, 0px));}vh-check 的核心原理也是上面所说的 window.innerHeight 结合 css var()最后页面在 safari 中的表现总算比较正常了，此类问题，目前来说没有完美的方案，姑且算是比较完美吧。","link":"/2020/09/15/浅谈 100vh 在移动端中的差异及解决方案/"},{"title":"对第四种布局 flex 弹性盒子布局的总结","text":"谈谈 flexflex 是 css3 中新增的一种布局方式，也就是弹性盒模型布局。弹性盒子中子元素可以在各个方向上进行布局，并且能以弹性尺寸来适应空间。而之前 css 标准中为我们提供了 3 中布局方案，也就是标准文档流布局、浮动布局、和定位布局。这几种布局方式搭配，可以搞定布局上常见的需求，但比如水平居中，和垂直居中，采用定位布局的方式，它不够语义化，并且不够灵活。所以在这种情况下，第 4 种布局方式：flex 布局就诞生了。它可以设置一个属性就能实现居中，并且可以随着窗口的缩放自适应。使用 flex 布局的话，首先需要设置父元素的 display 的值为 flex 或 inline-flex，也就是定义一个弹性容器。flex 的核心概念就是 容器 和 轴，容器包含外层的父容器和内层的子容器，轴包括主轴和交叉轴，可以说 flex 布局的特性全都构建在这两个概念上。flex 布局涉及的 css 属性除了 display 的值为 flex 和 inline-flex 外，共有 12 个属性，其中，父容器和子容器各 6 个。不过，常用的属性只有 4 个，子容器和父容器各 2 个。首先是父容器的属性：常用的两个属性：justify-content: 这个属性用于定义如何沿主轴方向排列子容器位置排列flex-start：沿着主轴方向的起始端对其flex-center：主轴居中对齐flex-end：主轴方向的末端对齐分布排列space-between：沿主轴均匀排列，首尾两端的子容器与父容器相切space-around：沿主轴均匀排列，位于首尾两端的子容器到父容器的距离是子容器间距的一半align-items：定义子容器如何沿交叉轴排列flex-start：交叉轴起始端对齐flex-center：居中对齐flex-end：尾端对齐baseline：基线对齐，这里的基线就是指首行文字，交叉轴的起点到首行文字距离最大的子容器将会与起始端相切以确定基线stretch：子容器沿交叉轴方向的尺寸将会拉伸到与父容器一致不太常用的属性：flex-wrap：这个属性可以设置子容器是否换行，不但可以顺序换行，还可以设置逆序换行nowrap：不换行wrap：换行显示wrap-reverse：反向换行显示flex-flow：轴与换行组合设置，flow 即流向，也就是可以设置子容器沿着哪个方向流动，流动到终点是否换行。是个复合属性，也就是 flex-direction 和 flex-flow 的结合。比如：row nowarp 或 column wrap 等组合align-content：子容器多行排列时，设置子容器沿交叉轴对齐的方式flex-start：起始端对齐center：居中对齐flex-end：交叉轴末端space-around：等边均匀分布，位于首尾两端的子容器到父容器的距离是子容器之间间距的一半space-between：沿交叉轴均匀分布，首尾两端的子容器与父容器相切stretch：尺寸沿交叉轴方向拉伸至与父容器一致接下来是子容器的属性：常用的两个属性：flex：这个属性定义子容器在主轴上如何伸缩，弹性盒模型，弹性，弹性，是有弹性的，它们会自动填充剩余的空间，这个伸缩的比例由 flex 属性的值决定这个值可以是数字，如 flex: 1 或 flex: 2这个值也可以是带单位的数字，如 flex: 15px这个值还可以是 none ，设置为 none 则不伸缩这个值是多个值的缩写，虽然可以 1-3 个值连用，但通常 1 个值就可以解决需求align-self：单独设置子容器如何沿交叉轴排列，可选值与 align-items 完全一致，align-self 的优先级更高不太常用的属性：flex-basis：表示在不伸缩的情况下，容器的原始尺寸。主轴方向为横向时，代表宽度；主轴方向为纵向时，代表高度flex-grow：子容器弹性增长比例，也就是拉伸因子flex-shrink：设置子容器弹性收缩比例。order：设置子容器的排列顺序数值，默认为 0 ，可以为负值，数字越小，排列位置越靠前，会覆盖 HTML 的原本排列。","link":"/2018/06/20/对第四种布局 flex 弹性盒子布局的总结/"},{"title":"浅谈 vue 在 created 和 mounted 请求异步数据的区别","text":"前言今天下班，日常在公交车上用手机浏览技术社区，刷文章。偶然看到一篇文章，其中一部分内容如下图：其大意是在 created 这个生命周期请求异步数据的话，请求过多，页面会长时间处于白屏。看到这我就不淡定了，请求不是异步的？怎么会影响到渲染呢？EventLoop 白学了？之后我将这张截图发给朋友讨论了一波，发现还是有挺多人搞不清楚其中的关键，都说在 mounted 阶段请求数据会比较好，在 created 请求可能会找不到需要渲染的元素之类的。于是就有了这篇文章的诞生。其他 “谣言”对于这个问题，我去搜索了一波，发现网上对此还有颇多的“谣传”。很多都说在 mounted 发送异步数据请求比较好，具体的原因大致分为以下几类。谣言1： 官方建议数据异步请求放在 mounted 钩子函数中进行官方有说过这句话？我翻遍了整个官方文档，也没发现官方在哪里建议在 mounted 钩子函数中进行异步数据请求。谣言2： created 阶段的异步数据请求与 mounted 请求的区别：前者页面视图未出现，如果请求数据过多，页面会长时间处于白屏状态首先，要明白请求是异步的，不会阻塞到页面的渲染。vue 生命周期钩子函数中的异步请求，会放在事件队列里面，不影响静态页面的加载，白屏只是因为组件加载得慢。谣言3： 在 created 中请求数据，可能 Vue 的虚拟 DOM 已经加载完成，但请求尚未完成，等请求响应完成，又得重新更新一遍虚拟 DOM，白屏时间长。而在 mounted 中发异步数据请求则只需更新部分 DOM 即可。这种说法，和上面一种类型，典型的只考虑了 vue 的生命周期，没有考虑到 JavaScript 的 EventLoop 。vue 生命周期钩子函数中的异步操作会放在事件队列中，也就是说不会在这个钩子函数中执行。所以在 created 和 mounted 中请求异步数据是一样的，两者都不会立即进行数据更新，所以不会导致虚拟 DOM 的重载，更不会影响到真实视图。谣言4：异步数据请求有快有慢，在 created 中请求的异步数据万一响应很快，此时 DOM 未完成渲染，找不到它需要渲染的 DOM 元素，会出现一些 bug。而在 mounted 中发送请求则不会。这种说法，纯属扯蛋。vue 生命周期钩子函数中异步数据的赋值，是不会在该钩子函数中执行的，而是在一遍流程结束后，才会处理其中的异步操作。所以本阶段不会触发数据更新，也不会触发虚拟 DOM 重新载入，更不存在找不到 DOM 元素渲染。实践检验真理虽然前面已经说的很清楚了，但实践是检验真理的唯一标准，还是直接上代码吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const app = new Vue({ el: '#app', data: { num: 0 }, async created() { console.log('created') this.num = await this.getData('created') console.log('获取异步数据结束') console.timeEnd('created获取异步数据完成时长') }, beforeMount() { console.log('beforeMounted') }, async mounted() { console.log('mounted') this.num = await this.getData('mounted') console.log('获取异步数据结束') console.timeEnd('mounted获取异步数据完成时长') }, updated() { console.log('updated') }, methods: { // 模拟异步请求 getData(lifecycle) { console.log(`${lifecycle}开始获取异步数据`) if (lifecycle === 'created') { console.time('created获取异步数据完成时长') } else { console.time('mounted获取异步数据完成时长') } const genRandomNum = (min, max) =&gt; (Math.random() * (max - min + 1) | 0) + min return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(genRandomNum(100, 3000)) }, 2000) }) } },})以上代码运行结果如下图所示，可以看到，在 created 和 mounted 中请求异步数据，都不会立即触发数据的更新，并且在这两个生命周期中获取异步数据更新的时长可以说是几乎一致的。vue 生命周期的钩子函数中的异步操作，都会在一遍流程走完之后，才会进行数据赋值操作，触发 update ，此外 DOM 的更新也是异步的，监听数据变化时，启动一个队列，进行视图更新。结论在 created 或 mounted 钩子函数中请求数据都是可以的。在 vue ssr 中，vue 的生命周期中没有 mounted 这个钩子函数，所以 ssr 中无法在 mounted 获取异步数据。宏任务之后是微任务，微任务过后是布局渲染，此时再执行请求后的回调并完成赋值。created 和 mounted 的区别就出现了，这样相比，created 中请求比 mounted 更快一点。也要考虑业务场景，需要 DOM 触发的请求，放在 created 中去，怎么放都请求不到。做学问要严谨，如有不对，望指出，感激不尽。","link":"/2019/12/19/浅谈 vue 在 created 和 mounted 请求异步数据的区别/"},{"title":"浅谈浏览器缓存机制","text":"前言在前端性能优化这一块上，利用好浏览器缓存可以说是最为简单高效的一中方式了，当然不只是在浏览器，不管是什么，利用好缓存都极大的提高性能。浏览器缓存机制也就是HTTP缓存机制，可以有效的减少网络传输所消耗的流量和时间，若所请求的资源在浏览器中存在缓存，那么则可以直接使用缓存而不发生请求，或者是发送请求但服务器上和客户端上的数据完全一致，不存在更新，那就不必再将数据回传给客户端，而是直接使用浏览器缓存，大大的减少了响应的数据，提高了性能。缓存的作用减少传输的数据，节省了流量使用缓存，不必发送请求或是不必回传数据，提高了效率客户端使用了缓存，服务器也无需传输数据给客户端减少了服务的的负担用户体验更好，比如类似PWA就是使用本地缓存的一种，虽然不是这里所讨论的HTTP缓存缓存策略一般来说浏览器缓存的策略分为：强缓存和协商缓存，设置缓存策略是通过设置 HTTP Header 来实现的。强缓存强缓存，客户端向服务器发送数据请求，请求成功后将数据缓存在本地，如果以后客户端再次请求该资源，则不需要再次向服务器发送资源请求，直接使用本地的缓存。强缓存的特点是：不需要与服务器发送交互，直接使用本地缓存。客户端访问强缓存的序列图请求的数据命中缓存：客户端请求数据，先在本地缓存数据库中查找该数据，若本地缓存数据库中存在该数据且数据未过期，则缓存系统返回该数据给客户端，不必向服务器发送请求。12客户端-&gt;缓存数据库:请求数据缓存数据库-&gt;客户端:请求的数据有缓存，并且未失效，返回数据请求的数据，未命中缓存：若请求的数据在本地缓存数据库中存在但已经过期，则客户端重新向服务器发送请求，服务器将新的数据和缓存规则一起返回给客户端，客户端接收后将它们一起放入缓存数据库中，以备下次使用。12345客户端-&gt;缓存数据库:请求数据缓存数据库-&gt;客户端:缓存失效客户端-&gt;服务器:请求数据服务器-&gt;客户端:返回新数据和缓存规则客户端-&gt;缓存数据库:将数据和缓存规则存入缓存系统中协商缓存协商缓存，顾名思义，就是缓存的数据是否发生改变需要发送请求与服务器进行协商，客户端需要向服务器发送请求询问数据是否更新。客户端第一次请求数据的时候，服务器响应请求会将缓存标识和数据主体一起返回给客户端，客户端接收到之后将它们备份至缓存数据库中。客户端再次请求该数据的时候，会将该数据的缓存标识发送给服务器，服务器根据缓存标识进行比较，若比较成功，则通知客户端所缓存的数据为发生改变，可以使用。实际应用场景demo总结正在编写中","link":"/2019/07/07/浅谈浏览器缓存机制/"},{"title":"记一次 Node.js 的 formidable 模块上传文件时 files 为空的问题， 顺便整理下相关内容","text":"前言使用原生来写 POST 的处理， 比较复杂， 而且文件上传业务比较的难写， 所以肯定有人造好了相关的轮子， 也就是 Node.js 的第三方模块 formidable ， 使用 formidable 当做中间件用来处理文件上传非常方便， 而且可以配合其他模块对文件进行相应的命名。不过在对 formidable 学习过程中出现了一个问题， 就是上传文件时， form.parse() 回调函数中 files 对象是个空对象。 就排查了挺久， 然后就以为问题是出在服务器端的代码上， 百度上关于这个问题也是寥寥无几， 众说纷纭。 没想到最后是前台页面 form 表单的问题， 也就是在 &lt;\\form&gt; 标签中我少写了一个 enctype 属性， 在使用包含文件上传控件的表单时，必须使用 enctype=”multipart/form-data” 也就是不对字符进行编码。安装 formidable 模块首先这里是 formidable 的 Github 地址， 可以 clone 下来， 也可以使用 npm 来安装1npm i -S formidable该模块放在 node_modules 文件夹中前台提交表单1234567891011121314151617181920&lt;form action=\"http://localhost:8080/postmsg\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;姓名： &lt;input type=\"text\" name=\"name\"&gt;&lt;/p&gt; &lt;p&gt;年龄： &lt;input type=\"text\" name=\"age\"&gt;&lt;/p&gt; &lt;p&gt; 性别： &lt;input type=\"radio\" name=\"sex\" value=\"男\"&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"女\"&gt;女 &lt;/p&gt; &lt;p&gt; 能力： &lt;input type=\"checkbox\" name=\"ability\" value=\"Python\"&gt;Python &lt;input type=\"checkbox\" name=\"ability\" value=\"C\"&gt;C &lt;input type=\"checkbox\" name=\"ability\" value=\"Java\"&gt;Java &lt;input type=\"checkbox\" name=\"ability\" value=\"JavaScript\"&gt;JavaScript &lt;/p&gt; &lt;p&gt; 照片： &lt;input type=\"file\" name=\"photo\"&gt; &lt;/p&gt; &lt;button type=\"submit\" name=\"button\"&gt;提交&lt;/button&gt; &lt;/form&gt;包含文件上传的表单一定要写 enctype 属性， 并且值要是 multipart/form-data。后台服务器处理1234567891011121314151617181920212223242526272829303132333435363738394041424344// 引入相关模块const http = require(\"http\"),url = require(\"url\"),util = require(\"util\"),formidable = require(\"formidable\");uuidv1 = require(\"uuid/v1\");path = require(\"path\");fs = require(\"fs\");// 创建服务器http.createServer((req, res) =&gt; { if (req.url === \"/postmsg\" &amp;&amp; req.method.toLowerCase() === \"post\") { // 实例化一个传入表单 let form = formidable.IncomingForm(); // 设置文件存储目录 form.uploadDir = \"./uploadDir\"; // 解析传入数据 form.parse(req, (err, fields, files) =&gt; { if (!err) { // 获取随机的名字 let name = uuidv1(); // 获取文件后缀名 let extName = path.extname(files.photo.name); // 获取老路径 let oldPath = __dirname + \"/\" + files.photo.path; // 设置新路径 let newPath = __dirname + \"/uploadDir/\" + name + extName; // 重命名 fs.rename(oldPath, newPath, (err) =&gt; { if (!err) { res.writeHead(200,{'content-type': 'text/html; charset=utf-8'}); res.write(\"写入成功！\"); res.write('received upload:\\n\\n'); res.end(util.inspect({fields: fields, files: files})); } else { throw err; } }); } else { throw err; } }); }}).listen(8080);在 Node.js 回调函数中， 一定要对 err 进行判断， 否则有时候错误令人莫名其妙。测试这个时候先运行服务器然后前端表单提交上传文件服务器响应到前端上传的文件会在项目文件 uploadDir 目录下总结创建Formidable.IncomingForm对象， 实例化一个传入表单 let form = new formidable.IncomingForm();form.uploadDir = &quot;/my/dir&quot;; 设置上传文件存放的文件夹，默认为系统的临时文件夹，可以使用fs.rename()来改变上传文件的存放位置和文件名form.maxFieldsSize = 2 \\* 1024 * 1024; 限制所有存储表单字段域的大小（除去file字段），如果超出，则会触发error事件，默认为2Mform.encoding = &quot;utf-8&quot;;设置表单域的编码form.parse(request, [callback]) 该方法会转换请求中所包含的表单数据更多请前往 官方文档…","link":"/2018/07/05/记一次 Node.js 的 formidable 模块上传文件时 files 为空的问题， 顺便整理下相关内容/"},{"title":"构建自己的前端知识体系","text":"前言在金庸的武侠世界中，习武之人讲究的是融汇贯通，打通自身经脉，才能达到内力生生不息。我虽非习武之人，但却是一名计算机从业者，需要足够扎实的理论基础才能撑得起各种实践。前端的知识太多太多，零零散散，需要从点到面去扩展，再由面到点的去深入，将这些知识联系起来构建自己的知识体系，加深理解，以便做到融会贯通。构建自己的知识体系的时候，用自己的话，将这些知识讲出来，讲清楚，以达到加深理解，整个过程中逐渐融汇贯通，业精于勤荒于嬉，行成于思毁于随。思维导图github 地址https://github.com/tflins/front-end-notes前端基础JavaScript数据类型数据类型判断数据类型null 和 undefined== 和 ===四则运算执行上下文、作用域、闭包执行上下文作用域链闭包this/bind/apply/callJavaScript 中的 this如何改变 this 指向bind 和 apply、call 的区别如何实现 apply、call如何实现 bind原型、继承JavaScript new 操作符的过程实现 new 操作符JavaScript 的原型介绍原型链是什么如何实现继承Promise、async/awaitPromise 是什么如何实现 Promiseasync/awaitasync/await 和 Promise 的区别EventLoopJavaScript 的 EventLoop浏览器的 EventLoop 和 node 的 EventLoop 的区别宏任务和微任务的区别深浅拷贝如何实现浅拷贝如何实现深拷贝Ajax什么是 Ajax实现一个 AjaxCSSposition行内元素/块状元素盒模型什么是盒模型如何改变盒模型各个盒模型的好处BFC/IFC外边距合并居中和常用布局flex 布局前端框架vuemvvm什么是 mvvm对 mvvm 的理解vue 双向绑定的原理生命周期vue 的生命周期父子组件的生命周期$nextTick 的原理组件通信父子组件通信祖孙组件通信兄弟组件通信状态管理什么是状态管理，为什么需要状态管理vuex 原理vue diff 算法vue computed、watch 原理虚拟 DOM为什么需要虚拟 DOM前端工程化webpackwebpack 是什么webpack 的构建流程loader 和 pluginwebpack 层面如何做性能优化介绍一下 webpack 的 dllbabelbabel 的工作原理介绍一下 AST性能优化持续更新中…","link":"/2019/03/05/构建自己的前端知识体系/"},{"title":"网页布局前的一些前置工作网页布局前的一些前置工作","text":"浏览器样式重置(CSS Reset)为什么要重置浏览器样式?因为不同的浏览器（ie,firefox,chrome等）,不同的核心对CSS的解析效果会有不同的呈现,和自己所期望的效果有所差异.如浏览器就会自己给body加上一条外边距(margin)的属性等,但有时候我们便不需要它,所以我们要重置浏览器样式.如何重置浏览器样式?CSS reset 在写的时候要慎重考虑,因为它有些元素会破坏浏览器的兼容性.但已经有前辈为我们总结了,顺风车.点击 normalize 进去,根据自己的需要进行link链接就行了.CSS的一些前置工作为什么要做css前置工作?因为我们的网页越复杂,它所重复用到的一些样式就特别多,如居中,浮动,和清除浮动等经常用到的样式我们希望在布局工作中能够轻松一些所以我们就可以对那些经常使用的样式把他们归到一个类中.我总结了我一些经常用到的,记录在下面:保持一定宽度并居中{1234display: block;max-width: 1080px; margin: 0 auto;}向左(向右)浮动{12float: left;}{12float: right;}对子元素清除浮动12345.clear-float:before { content: &quot; &quot;; display: block; clear: both; }元素所占比例设置(类似格栅)123456789101112.col-2,.col-3,.col-4,.col-5,.col-6,.col-7,.col-8,.col-9 { display: block; position: relative; min-height: 1px; } {12width: 10%;} {12width: 20%;} {12width: 30%;} **以下雷同省略...** 待补充…","link":"/2018/04/12/网页布局前的一些前置工作/"},{"title":"记一次前后端分离使用 token 登录解决方案（node jwt + Vue axios）","text":"前言最近在帮校友写一个项目，欣音悦（以歌单歌单分享为主的音乐 webapp）。这是一个类似于 QQ 音乐的 webapp 目前还在开发中，其中歌曲数据和歌手数据来自于 QQ 音乐的接口，而歌单数据则存在本地数据库中。校友的需求是用户能添加歌单并分享，能听歌，能评论。所以就涉及用户登录状态保持，而我也是首次尝试使用后 token 方案进行登录处理，所以就写这篇博文记录下。整理思路在用户首次登录的时候，服务器会判断用户登录信息是否匹配（账户密码等），若匹配则生成一个包含相关用户信息的 token，并返回给前端，前端可以将这个 token 解析得到相关用户数据。前端拿到 token 后，会将它存在 localStorage 或 Vuex 中。而每次前端路由跳转时，判断 localStorage 或 Vuex 中是否存在 token，若存在则获取用户信息，改变登录状态。若不存在则跳转到登录组件。设置一个 HTTP 拦截器，在每次请求中，请求头携带 token。服务器判断请求头中是否存在 token ，若不存在或过期，返回 401 。前端得到 401 则重定向到登录组件。后端接口在写这个项目的时候，服务器我采用的是 Node.js ，而 WEB 框架，则采用 Koa2 ，数据库则使用 Mongodb 。生成 token ，需要一个模块 jsonwebtoken ，使用 npm 安装即可。在服务器中处理用户信息相关接口的路由文件 users.js 中的登录接口，处理逻辑如下：将用户 E-mail 和 password 从执行上下文提取出来后，与数据库中的信息进行匹配。若成功，则生成 token 返回。具体登录接口代码如下：12345678910111213141516171819202122232425262728293031323334353637/** * @router GET api/users/login * @desc 登录接口地址 返回token * @access 接口是公开的 */router.post('/login', async ctx =&gt; { // 查询当前登录邮箱是否在数据库中 const findResult = await User.find({ email: ctx.request.body.email }) if (!findResult.length) { ctx.state = 404 ctx.body = { email: '用户不存在！' } } else { const user = findResult[0] // 查到后 验证密码 const result = await bcrypt.compareSync( ctx.request.body.password, user.password ) // 密码验证通过 if (result) { // 返回token const payload = { id: user.id, name: user.name, avater: user.avatar } const token = jwt.sign(payload, keys.secretOrKey, { expiresIn: 60 * 60 }) ctx.state = 200 ctx.body = { success: true, token: `Bearer ${token}` } } else { ctx.state = 400 ctx.body = { password: '密码错误！' } } }})对登录接口进行测试，邮箱和密码正确的话可以看到，此时，服务器已经返回给了一个 token。前端处理在前端正确登录，拿到 token 后，就需要将她存储起来，也就是在登录组件中，对token进行存储：123456789101112131415161718methods: { _login() { const userInfo = { email: this.email, password: this.password } login(userInfo).then(res =&gt; { if (res.success) { // 保持到 localStroage 中 localStorage.setItem('token', res.token) // 跳转到 / 路由 location.replace('/') } }).catch(err =&gt; { throw err }) } }上面代码中的 login 方法，已经封装到 useruser.js 中了，直接调用就行，其主要代码如下：1234567891011121314export function register(userInfo) { const url = 'http://localhost:5000/api/users/register' const data = Object.assign({}, userInfo) return axios .post(url, data) .then(response =&gt; { return Promise.resolve(response.data) }) .catch(err =&gt; { throw err })}在 router 的 index.js 中，就可是使用 loaclStorage.token 来进行前端路由拦截，非登录页面若 localStorage.token 不存在，则跳转到登录页。1234567//路由跳转之前router.beforeEach((to, from, next) =&gt; { if (to.path !== '/login' &amp;&amp; !localStorage.token) { return next('/login') } next()})效果如图所示","link":"/2019/03/20/记一次前后端分离使用 token 登录解决方案（node jwt + Vue axios）/"},{"title":"谈谈 JS 中 __proto__ 和 prototype","text":"前言在学习 JavaScript 的过程中， 深感这门语言的一些奇葩设定， 在学习 __proto__ 和 prototype 时， 遇到了一些困惑， 思考了挺久也查阅了很多资料， 于是写了这篇博客来记录。在 JavaScript 中万物皆对象， Object 作为一个基础类型， 其他是引用继承 Object 而来， 所以每个对象都有一个 __proto__ 属性，但 prototype 是只有函数才有的属性prototype （显式原型）先说说 prototype， 几乎所有函数在创建的时候， 会有一个叫 prototype 的属性（通过 Function.prototype.bind 方法构造出来的函数是个例外，它没有 prototype 属性）， 这是一个指针， 指向函数的原型对象。 而这个原型对象是用来实现基于原型的继承与属性的共享， 可以让所有对象实例共享它所包含的属性和方法。也就是说不必在构造函数中定义对象实例的信息， 而是添加在原型对象中。__proto__ (隐式原型)对象具有 __proto__ 属性， 也就是隐式原型， 这个属性也是指针， 指向该对象的构造函数的显式原型。 隐式原型的作用是构成原型链，同样用于实现基于原型的继承。比如，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着proto依次查找。12// __proto__ 指向该对象的构造函数的 prototypeconsole.log(Array.__proto__ === Array.constructor.prototype); // true上面的代码中 .proto === .constructor.prototype 结果为 true， 但这也不是一定的。 如函数的prototype属性被瞎改的话， 或者如果一个对象是通过Object.create函数构造出来的，那其__proto__就不是.constructor.prototype了。既然是对象都有 __proto__ 属性， 那么原型对象的 __proto__ 又指向谁呢？12// Object.prototype 的 __proto__ 属性指向 nullconsole.log(Object.prototype.__proto__); // null总结1.对象有属性__proto__,指向该对象的构造函数的原型对象。2.方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。3.Object.prototype 的 __proto__ 属性指向 null。","link":"/2018/05/28/谈谈 JS 中的 -__proto__ 和 prototype/"},{"title":"Node.js + Express + mongodb 的博客项目之保持用户登录，区分管理员账户，及用户登出（四）","text":"前言在上一节中，完成了用户的注册与登录，但是并没有保持用户登录，一刷新浏览器登录状态就没有了。所以在本节内容中将实现用户登录状态的保持，同时进行普通用户与博客管理员的区别，并且实现用户登出接口。Cookie想要维持住登录状态，就得借用 Cookie，Cookie 是服务器给客户端发的一段数据，可以比作通行证，客户端需要保存这段数据，不得随意删除。此后客户端每次访问服务器的时候都要携带上这段数据，这样服务器就能通过这段数据来确认用户的身份了。Cookie 一般有两个作用：第一个就是识别用户身份，比如用户 a 访问了 tlin.com ，那么 tflin.com 的服务器就会给 a 返回一段数据 [uid = 1]，以后 a 不管访问 tflin.com 的任何页面都会携带上 [uid = 1] 这段数据，这样就能根据这段数据进行身份识别了。第二个就是记录历史，也就是比如那些购物网站上的未登录的购物车，同样是借用 Cookie 。当 a 将商品介入购物车时，可以使用 Js 对 Cookie 进行修改，保存相应的记录。这样一来，关闭网页后，即使用户没有登录，再次打开网页，商品依旧安安静静的躺在购物车里。保持用户登录在本项目中，使用 Cookies 模块来设置 Cookie，这是他的官方文档 Cookies API。我们先在项目的入口文件 app.js 中引入 Cookies 模块并进行中间件设置，在 app.js 添加如下代码：1234567891011121314151617// 引入cookies模块const Cookies = require(\"cookies\");// cookies配置app.use((req, res, next) =&gt; { // 向请求体对象中新加一个cookies属性，对应当前请求，相应 req.cookies = new Cookies(req, res); // 给req对象增加一个用户信息的属性，以便所有路由都能读取 req.userInfo = {}; // 如果客户端中有cookie信息 if (req.cookies.get(\"userInfo\")) { // 将其解析后存入req.userInfo中 req.userInfo = JSON.parse(req.cookies.get(\"userInfo\")) } // 继续下一个中间件 next();});然后在修改登录接口，在其登录成功的时候设置 cookie 信息，将 routes/api 中的登录接口修改为如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 用户登录的接口 提交的验证： 1.用户名不能为空 2.密码不能为空 数据库的验证： 1.用户名是否存在 2.若存在密码是否正确*/router.post(\"/user/login\", (req, res, next) =&gt; { // 用户名 let username = req.body.username; // 密码 let password = req.body.password; console.log(password); // 用户名不能为空 if (username === \"\") { responseData.code = 1; responseData.message = \"用户名不能为空！\"; res.json(responseData); return; } // 密码不能为空 if (password === \"\") { responseData.code = 2; responseData.message = \"密码不能为空！\"; res.json(responseData); return; } // 向数据库查询，用户是否存在 userModel.findOne({username: username}, (err, user) =&gt; { // 如果存在该用户 if (user) { // 验证密码是否正确 if (user.password === password) { responseData.message = \"登录成功！\"; // 在responseData中新建一个用户信息的属性 responseData.userInfo = { username: user.username, userid: user._id }; // 设置cookie信息 req.cookies.set(\"userInfo\", JSON.stringify(responseData.userInfo)); res.json(responseData); return; } else { responseData.code = 5; responseData.message = \"密码不正确！\"; res.json(responseData); return; } } else { responseData.code = 6; responseData.message = \"该用户名不存在！\"; res.json(responseData); return; } });});这个时候我们已经将 cookie 的相关设置配置完成，当在用户登录成功的时候，服务器向客户端发送一个 cookie 信息，并且将 cookie 信息存到 req..userInfo 中，就可以将 req.userInfo 当做数据绑定给模板引擎。模板引擎则根据 req.userInfo 是否存在来判断用户是否已登录。首先先在 /routes/main.js 中将 req.userInfo 分配给模板引擎：12345678// 首页路由配置router.get(\"/\", (req, res) =&gt; { // 渲染首页模板 res.render(\"main/index\", { // 给模板引擎绑定数据 userInfo: req.userInfo });});接着就可在前台的页面 views/main/index.ejs 中使用所绑定的数据了，并以此来判断用户是否登录，思路如下：如果 userInfo 存在则渲染用户信息面板，若不存在则渲染登录/注册面板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div class=\"col-md-4\"&gt; &lt;%if (!userInfo.userid) {%&gt; &lt;!-- 登录面板 --&gt; &lt;div id=\"login\"&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"login-btn\"&gt;登录&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;没有账号？点击注册&lt;/a&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注册面板 --&gt; &lt;div id=\"reg\" class=\"hide\"&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户名称&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;输入密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;确认密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"repassword\" placeholder=\"请再次输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"reg-btn\"&gt;注册&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;已有账号？点击登录&lt;/a&gt; &lt;!-- 警告框 --&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;%} else {%&gt; &lt;!-- 用户面板 --&gt; &lt;div id=\"user-info\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt;用户面板&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;h3&gt;欢迎，&lt;%=userInfo.username%&gt;！&lt;/h3&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-danger form-control\"&gt;注销&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%}%&gt; &lt;/div&gt;改完前台模板，我们的登录的 ajax 请求登录成功后的函数也要进行相应的修改，将登录成功后隐藏登录面板改为刷新页面，因为此时 cookie 已存在，所以刷新页面后，模板会自动渲染出用户信息面板：12345678910success: (result) =&gt; { if (result.code) { $warningBox.find(\"span\").html(\"警告：\" + result.message); $warningBox.addClass(\"alert-danger\") $warningBox.removeClass(\"hide alert-success\"); } else { // 重新加载页面 window.location.reload(); } }最后我们在客户端浏览器中进行测试，发现此时用户登陆后，无论怎么刷新，还是保持着登录状态。用户登出接口用户登出接口则只要将 cookie 清空即可，在 /routes/api.js 中添加如下代码：123456// 用户登出接口router.get(\"/user/logout\", (req, res, next) =&gt; { // 将cookie设为null req.cookies.set(\"userInfo\", null); res.json(responseData);});然后在前端用 ajax 请求：123456789101112// 用户登出 $logoutBtn.on(\"click\", () =&gt; { $.ajax({ type: \"get\", url: \"/api/user/logout\", success: (result) =&gt; { if (result) { window.location.reload(); } } }); });重启服务器进行测试：到此，用户的登录注册及登出完成。管理员与普通用户的区别在数据库中，用户集合中有一个字段为 isadmin 这个字段就是是否是管理员，默认为 false，我们可以根据这个字段来判断当前登录的用户是否是管理员。具体步骤是将其从数据库中读取出来然后存放到 req.userInfo 中，与其他页面共享，绑定到模板引擎中，根据 isadmin 的值渲染不同的界面。在项目的入口文件 app.js 先将用户的模型引用进来：12// 引用用户模型对象const userModel = require(\"./models/user\");再cookies 配置的中间件中修改为如下代码：12345678910111213141516171819202122// cookies配置app.use((req, res, next) =&gt; { // 向请求体对象中新加一个cookies属性，对应当前请求，相应 req.cookies = new Cookies(req, res); // 给req对象增加一个用户信息的属性，以便所有路由都能读取 req.userInfo = {}; // 如果客户端中有cookie信息 if (req.cookies.get(\"userInfo\")) { // 将其解析后存入req.userInfo中 req.userInfo = JSON.parse(req.cookies.get(\"userInfo\")); // 根据用户id从数据库中查询出当前登录用户的信息 userModel.findById(req.userInfo.userid).then((user) =&gt; { // 以此判断当前用户是否为管理员 req.userInfo.isadmin = user.isadmin; next(); }); } else { // 继续下一个中间件 next(); }});然后将博客主页的模板中的用户面板部分修改为如下:12345678910111213141516171819&lt;!-- 用户面板 --&gt; &lt;div id=\"user-info\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt;用户面板&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;%if (userInfo.isadmin) {%&gt; &lt;h3&gt;欢迎尊贵的管理员，&lt;%=userInfo.username%&gt;!&lt;/h3&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-danger form-control\"&gt;进入控制台&lt;/button&gt; &lt;/p&gt; &lt;%} else {%&gt; &lt;h3&gt;欢迎您，&lt;%=userInfo.username%&gt;！&lt;/h3&gt; &lt;%}%&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" id=\"logout\" class=\"btn btn-danger form-control\"&gt;注销&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;接着把数据库中的 admin 账户的 isadmin 置为 true 然后重启服务器到客户端浏览器上测试一下：此时管理员账户与普通用户账户已经区分出来了。","link":"/2018/07/27/Node.js + Express + mongodb 的博客项目之保持用户登录，区分管理员账户，及用户登出（四）/"},{"title":"JavaScript 数组对象 Array","text":"前言在 JavaScript 中引用类型除了 Object 外,最常用的恐怕就是 数组 Array 了。 都说 JavaScript 中万物基于对象（但我觉得这句话有些时候也是有些坑的）, 所以 Array 对象也有很多它内置的方法。JavaScript 是弱类型语言， 所以我们不用声明就可以直接使用了， 但这样是比较不推荐的。 JavaScript 中的数组也是个有序列表， 但和其他语言有所不同的是， JavaScript 数组中的每一项都可以保存任何类型的数据。 有点像 Python 中的列表， 我们可以用数组中的第一项保存一个数字， 第二项保存一个字符串， 而第三项可以保存一个 Object， 没有任何限制。 并且其数组大小是动态调整的， 可以随数据增长而自动增大数组大小。创建数组的方法在 JavaScript 中创建数组有两种方法：第一种是使用 Array 的构造函数1234var 数组名 = new Array();var 数组名2 = new Array(20); //向Array对象构造函数传递参数指定数组大小var 数组名3 = new Array(\"Tflin\", \"Lyfei\", \"Zshan\"); //创建具体项的数组var 数组名4 = Array(); //也可以省略new操作符第二种是使用是使用数组字面量表示法123var 数组名 = []; //创建一个空数组var 数组名2 = [\"Tflin\", \"Lyfei\", \"Zshan\"]; //创建具体项的数组var 数组名3 = [,,,,]; //虽然这样也行，但这是有歧义的，不建议！会创建一个人包含5或6项的数组数组在使用字面量表示法时， 和对象一样， 是不会调用Array构造函数的（Firefox 3 及更早版本除外）。访问数组和其他语言的数组并无多大区别， 使用数组的下标来访问数组12345var name = [\"Tflins\", \"Lyfei\", \"Zshan\"];console.log(name[0]); //显示第一项name[1] = \"Lxyu\"; //修改第二项name[3] = \"Whzhen\" //新增第四项， 数组大小是动态调整的consloe.log(name[4]) //undefined在方括号中的索引表示要访问数组的值，如果索引小于数组中的项数 (arrName.length)， 则返回数组中对应的值， 如果大于数组中的项数， 则返回 undefined 未定义。数组的项数保存在 length 属性中。如12var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; //创建一个包含3个字符串的数组console.log(name.length); //3但 javascript 中 length 属性并不是只读的， 因此可以调整 length 的值， 来移除数组中的项或者添加新项。 如123var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; //创建一个包含3个字符串的数组name.length = 2;console.log(name[2]); //undefined我们已经把 length 的值改为 2， 所以访问下标为 2（第三项） 的值时， 得到一个特殊的值 undefined。当然利用 length 我们也可以很方便的在数组添加新的一项， 因为数组中最后一项的索引始终是 （length - 1） 。 如123var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; //创建一个包含3个字符串的数组name[name.length] = \"Whzhen\"; //在位置 3 添加一项name[name.length] = \"Lxyu\"; //在位置 4 添加一项检测数组在 javascript 中， 我们可以用 type of() 方法来检测其数据类型， 但是有个奇怪的事情， 就是我们使用 type of 检测数组时， 它会返回一个 Object， 而不是 Array， 这是有歧义的事情。当然我们也可以使用 instanceof 来进行检测， 就可以得到满意的答案， 如12var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; consloe.log(name instanceof Array); //true不过在使用 instanceof 时， 它的问题在于， 如果网页中含有多个框架， 则便存在连个以上不同的全局执行环境， 从而可能存在两个以上不同版本的 Array 构造函数， 如果从一个框架向另一个框架传递数组， 那么传入的数组将与另一个框架中的数组具有不同的构造函数。所以在 ECMAScript 5 中新增了 Array.isArray() 方法， 这个方法就是用来检测一个值是不是一个数组的， 也不管其是在哪个全局执行环境创建的。 用法如下12var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; consloe.log(Array.isArray(name)); //true转换方法javascript 中所有对象都具有 toLocaleString()、toString()、valueOf()方法。valueOf()调用这个方法返回的是数组本身12var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; consloe.log(name.valueOf()); //Tflins, Lyfei, ZshantoString()这个方法会返回一个由数组中每个值得字符串形式拼接而成的字符串， 并由逗号隔开12var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; consloe.log(name.valueOf()); //Tflins, Lyfei, ZshantoLocaleString()toLocaleString() 是把数组转换为本地数组，并返回结果。LocaleString() 会根据你机器的本地环境来返回字符串， 它和 toString() 返回的值在不同的本地环境下使用的符号会有微妙的变化。因此使用toString()是保险的， 返回唯一值的方法,它不会因为本地环境的改变而发生变化。 如果是为了返回时间类型的数据， 推荐使用LocaleString()。 若是在后台处理字符串，必使用toString()。数组 栈方法在 JavaScript 中， 数组也提供了类似数据结构中的一些方法。 可以让数组像栈一样， 具有后进先出的特点。push() 推入方法push() 可以接受任意数量但值， 并把它们逐个添加到数组末尾， 修改并返回 length 属性。1234var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; var count = name.push(\"Lxyu\", \"Cbyi\"); //推入两项console.log(count); //5consloe.log(name.valueOf()); //Tflins, Lyfei, Zshan, Lxyu, Cbyipop() 弹出方法pop() 则是从数组末尾移除最后一项， 减少 length 的值， 然后返回被移除（弹出）的一项1234var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; var item = name.pop(); //弹出一项console.log(item); //Zshanconsloe.log(name.valueOf()); //Tflins, Lyfei数组 队列方法队列是一种 FIFO 新进新出的数据结构， 从列表末端添加新项， 从前端移除数据项， 因此可以使用 push() 和 shift() 方法来模拟这一结构。shift()这个方法能够移除数组中的第一项， 并返回该项， 同时减少 length 的长度 1 。12345var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; var count = name.push(\"Lxyu\"); //推入一项console.log(count); //4var item = name.shift(); //取得移除的第一项consloe.log(name。valueOf()); //Lyfei， Lxyu在 JavaScript 中，还位数组提供了一个 unshift() 方法， 顾名思义就是 shift() 的用途反过来。unshift()该方法能在数组前端添加任意个项的值， 并返回新数组的长度 ， 所以可以配合 pop() 方法来反向模拟队列。 即在数组前端添加新项， 末端移除项。 如12345var name = [\"Tflins\", \"Lyfei\", \"Zshan\"]; var count = name.unshift(\"Lxyu\"); //在数组前端添加一项console.log(count); //4var item = name.pop(); //取得移除的第最后一项consloe.log(name.valueOf()); //Lxyu, Tflins, Lyfei重排序方法在数组中， 有两个可以直接用来重排序的方法： reverse() 与 sort()，+++++++++++++++++++++++++ 这两个方法返回的都是重排序后的数组。reverse()这个方法可以反转数组的顺序， 如123var arr = [1, 2, 3, 4];arr.reverse();alert(arr); //4, 3, 2, 1sort()这个方法在默认的情况下按升序排序数组， 为了实现排序 sort() 会调用每个数组项的 toString() 方法, 将其转换成字符串， 因此 sort() 方法比较的是字符串， 如123var arr = [4, 3, 2, 1, 44, 5, 55];arr.sort();alert(arr); //1, 2, 3, 4, 44, 5, 55在上述例子中数值 5 虽然小于 44， 但 sort() 比较的是字符串， “44” 在 “5” 的前面， 所以便产生了这样的结果。 所以 sort() 在多种情况下并不是最佳方案。 为了解决这一问题， 可以使用 sort() 方法来接受一个比较函数， 这个比较函数用于决定哪个值位于哪个值的前面， 如1234567891011121314//比较函数function compare(value1, value2) { if(value1 &lt; value2) { return -1; } else if(value1 &gt; value2) { return 1; } elae { return 0; }}var arr = [4, 3, 2, 1, 44, 5, 55];arr.sort(compare);alert(arr); //1, 2, 3, 4, 5, 44, 55上述例子中， 使用 sort() 接受了一个比较函数， 所以在排序数值时仍然保持了正确的升序。数组操作方法JavaScript 为操作数组提供了很多的方法，concat()concat() 方法会创建一个副本数组， 然后将接收到的参数添加到这个副本的末尾， 最后返回新构建的整个数组，简单的说就是合并。 如1234var arr1 = [1, 2, 3];var arr2 = arr1.concat(\"Tflin\", [4, 5]);alert(arr1); //1, 2, 3alert(arr2); //1, 2, 3, Tflin, 4, 5slice()这个函数有点类似 Python 中的切片， 它能够基于当前数组中的一个或多个项创建一个新数组。 slice() 方法接收一或两个参数。 如果有一个参数， 则返回该项到数组末尾的所有项。 如果有两个参数， 第一个参数为起始项， 第二个参数为末尾项， 返回起始项到末尾项之间所有的项， 但不包括末尾项。 如12345var arr1 = [1, 2, 3， 4， 5, 6];var arr2 = arr1.slice(1) //一个参数,返回该项到数组末尾的所有项var arr3 = arr1.slice(2, 4) //两个参数, 回起始项到末尾项之间所有的项， 但不包括末尾项。alert(arr2); //2alert(arr3); //3, 4slice() 方法接收的参数， 如果是负数的话， 则使用参数与数组的 length 相加得到相应位置， 如在 length 为 5 的数组中 slice(-2， -1) 与 slice(3, 4) 得到的结果是一样的。 结束位置小于起始位置则返回空数组。splice()这个方法恐怕是数组中最强大的方法了， 它有很多种用法， 主要功能是向数组中部插入项。 如删除splice(0, 2) 第一个参数是要删除的第一项的位置， 第二个参数则是要删除的项数。 splice(0, 2) 便是删除数组中的前两项。插入splice() 可以向指定的位置插入项， 需要接受三个参数,","link":"/2018/05/15/JavaScript 数组对象 Array/"},{"title":"Node.js + Express + mongodb 的博客项目之博客内容的后台管理（七）","text":"前言博客内容的管理，与博客文章分类的管理基本上类似。都是分别有几个路由对应相应的功能，GET /admin/content 对应文章内容的首页，GET /admin/content/add 对应内容的添加，GET /admin/content/edit 是内容的修改编辑，GET /admin/content/delete 则为博客内容的删除路由。博客内容在数据库中的存储结构与模型文章的内容的数据结构主要有文章的标题，分类，作者，添加时间，阅读量，简介，正文部分。其中分类和作者是引用其对应的集合而来，添加时间则是通过时间格式化模块 moment 格式化后转化为字符串。在 /schemas 文件夹中新建一个 contents.js 文件，用来存放文档结构，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 引入mongoose模块const mongoose = require(\"mongoose\");// 引入时间格式化模块const moment = require(\"moment\");/* 文章内容的数据结构 { 标题，字符串类型 分类id，引用对象 作者，引用对象 添加时间，字符串 阅读量，字符串 简介，字符串 正文，字符串 }*/module.exports = new mongoose.Schema({ title: String, category: { type: mongoose.Schema.Types.ObjectId, ref: \"category\" }, author: { type: mongoose.Schema.Types.ObjectId, ref: \"user\" }, addTime: { type: String, default: moment().format('YYYY-MM-DD h:mm:ss a') }, views: { type: Number, default: 0 }, description: { type: String, default: \"\" }, content: { type: String, default: \"\" }});然后在 /models 中添加内容的模型 content.js123456// 引入相关模块const mongoose = require(&quot;mongoose&quot;);const contentSchema = require(&quot;../schemas/contents.js&quot;);// 文章内容的模型对象module.exports = mongoose.model(&quot;content&quot;, contentSchema);内容相关的静态模板在视图文件夹 /views 中的 /admin/ 新建一个 /content 文件夹用来存放文章内容相关的视图文件。管理首页模板在 /views/admin/content 中新建一个 index.ejs 作为内容管理的首页，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;内容首页&lt;/li&gt; &lt;/ol&gt; &lt;table class=\"table table-hover table-striped table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;添加时间&lt;/th&gt; &lt;th&gt;阅读量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;%for(let i = 0, len = docs.length; i &lt; len; i++){%&gt; &lt;tr&gt; &lt;td&gt;&lt;%=docs[i]._id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].category.name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].title%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].author.username%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].addTime%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].views%&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/admin/docs/edit?id=&lt;%=docs[i]._id%&gt;\" class=\"btn btn-default\"&gt;修改&lt;/a&gt; &lt;a href=\"/admin/docs/delete?id=&lt;%=docs[i]._id%&gt;\" class=\"btn btn-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;%}%&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;!-- 引入分页模板 --&gt;&lt;%- include(\"../../pagination\") %&gt;&lt;/body&gt;&lt;/html&gt;内容添加页面模板接着再新建一个内容添加页面 /views/admin/content/add.ejs 内容如下：1234567891011121314151617181920212223242526272829303132333435&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt; &lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/content\"&gt;内容首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;内容添加&lt;/li&gt; &lt;/ol&gt; &lt;form method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"title\"&gt;分类&lt;/label&gt; &lt;select name=\"category\" id=\"category\" class=\"form-control\"&gt; &lt;%for(let i = 0, len = categories.length; i &lt; len; i++){%&gt; &lt;option value=\"&lt;%=categories[i]._id%&gt;\"&gt;&lt;%=categories[i].name%&gt;&lt;/option&gt; &lt;%}%&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"title\"&gt;标题&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\" placeholder=\"请输入标题\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"description\"&gt;简介&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"description\" name=\"description\" placeholder=\"请输入简介\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"content\"&gt;正文&lt;/label&gt; &lt;textarea name=\"content\" rows=\"9\" class=\"form-control\" placeholder=\"请输入正文\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;内容修改界面模板最后一个界面则是博客内容的修改界面 /views/content/edit.ejs ：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/content\"&gt;内容首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;内容修改&lt;/li&gt; &lt;/ol&gt; &lt;form method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"title\"&gt;分类&lt;/label&gt; &lt;select name=\"category\" id=\"category\" class=\"form-control\"&gt; &lt;%for(let i = 0, len = categorys.length; i &lt; len; i++){%&gt; &lt;%if((content.category).toString() === categorys[i]._id.toString()){%&gt; &lt;option value=\"&lt;%=categorys[i]._id%&gt;\" selected=\"selected\"&gt;&lt;%=categorys[i].name%&gt;&lt;/option&gt; &lt;%}else{%&gt; &lt;option value=\"&lt;%=categorys[i]._id%&gt;\"&gt;&lt;%=categorys[i].name%&gt;&lt;/option&gt; &lt;%}%&gt; &lt;%}%&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"title\"&gt;标题&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\" placeholder=\"请输入新标题\" value=\"&lt;%=content.title%&gt;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"description\"&gt;简介&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"description\" name=\"description\" placeholder=\"请输入新简介\" value=\"&lt;%=content.description%&gt;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"content\"&gt;正文&lt;/label&gt; &lt;textarea name=\"content\" rows=\"9\" class=\"form-control\" placeholder=\"请输入新正文\"&gt;&lt;%=content.content%&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;修改&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;博客内容管理的相关内容处理在处理完博客内容管理的先关静态模板后，就进行相关路由的处理。博客内容首页的路由在 admin.js 中，添加如下代码：1234567891011121314151617181920212223// 引入内容的模型，用来操作数据库const contentModel = require(\"../models/content\");// 博客内容管理首页router.get(\"/content\", (req, res, next) =&gt; { // 调用自定义的分页渲染方法 pagination({ // 每页显示的条数 limit: 10, // 需要操作的数据库模型 model: contentModel, // 需要控制分页的url url: \"/admin/content\", // 渲染的模板页面 ejs: \"admin/content/index\", // 查询的条件 where: {}, // 需要跨集合查询的条件 populate: [\"category\", \"author\"], res: res, req: req });});博客内容添加界面保存路由在 admin.js 中添加如下代码，实现对 /admin/content/add 路由的 GEt 和 POST 处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 博客内容的添加界面router.get(\"/content/add\", (req, res, next) =&gt; { // 从数据中读取分类信息 categoryModel.find({}, (err, categories) =&gt; { if (!err) { res.render(\"admin/content/add\", { userInfo: req.userInfo, categories: categories }); return; } else { throw err; return; } });});// 内容添加的保存router.post(\"/content/add\", (req, res, next) =&gt; { let title = req.body.title; let category = req.body.category; let description = req.body.description; let content = req.body.content; // 后端进行简单的验证 if (title === \"\") { // 如果标题为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"标题不能为空\" }); return; } else if (description === \"\") { // 如果简介为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"简介不能为空\" }); return; } else if (content === \"\") { // 如果正文为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"正文不能为空\" }); return; } else { // 一切正常，存入数据库 contentModel.create({ title: title, category: category, author: req.userInfo.userid.toString(), description: description, content: content }, (err) =&gt; { if (!err) { // 保存成功 res.render(\"admin/success\", { url: \"/admin/content\", userInfo: req.userInfo, message: \"提交成功！\" }); } else { throw err; } }); }});内容的修改界面及保存修改的路由内容的修改是由前端通过 GET 方式向后端传递需要修改的内容的 ID ，后端再从数据库中查询出相应数据进行更新，并将处理结果返回给前端。在 admin.js 中添加以下代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 内容修改的界面router.get(\"/content/edit\", (req, res, next) =&gt; { // 获取需要修改内容的id let id = req.query.id; // 从数据库中查询 contentModel.findById(id, (err, content) =&gt; { if (content) { // 如果数据存在，从数据库中查询出所有分类 categoryModel.find({}, (err, categories) =&gt; { if (!err) { // 渲染修改模板视图 res.render(\"admin/content/edit\", { userInfo: req.userInfo, categories: categories, content: content }); } else { throw err; } }); } else { // 如果该内容不存在 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"该内容不存在！\" }); } });});// 内容的修改保存router.post(\"/content/edit\", (req, res, next) =&gt; { // 获取数据 let title = req.body.title; let category = req.body.category; let description = req.body.description; let content = req.body.content; let id = req.query.id; // 后端进行简单的验证 if (title === \"\") { // 如果标题为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"标题不能为空!\" }); return; } else if (description === \"\") { // 如果简介为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"简介不能为空!\" }); return; } else if (content === \"\") { // 如果正文为空，渲染错误页面 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"正文不能为空!\" }); return; } else { // 一切正常，更新数据库 contentModel.update({ _id: id }, { title: title, category: category, description: description, content: content }, (err) =&gt; { if (!err) { // 保存成功 res.render(\"admin/success\", { url: \"/admin/content\", userInfo: req.userInfo, message: \"修改成功！\" }); } else { throw err; } }); }});内容删除的处理删除同样是前端通过 GET 方式传递需要删除的内容的 ID 过来，然后服务器再从数据库根据 ID 删除数据。在 admin.js 中添加如下代码，处理删除内容：12345678910111213141516171819202122232425// 内容的删除router.get(\"/content/delete\", (req, res, next) =&gt; { // 获取id let id = req.query.id; // 根据id删除数据 contentModel.remove({ _id: id }, (err) =&gt; { if (!err) { // 删除成功 res.render(\"admin/success\", { url: \"/admin/content\", userInfo: req.userInfo, message: \"删除成功！\" }); } else { // 出错 res.render(\"admin/error\", { url: \"/admin/content\", userInfo: req.userInfo, message: \"删除失败！\" }); } });});内容管理的测试最后进行内容管理的相关测试：","link":"/2018/08/02/Node.js + Express + mongodb 的博客项目之博客内容的后台管理（七）/"},{"title":"Node.js + Express + mongodb 的博客项目之博客文章内容详情界面及文章评论（九）","text":"前言本节内容中将实现博客的文章详情页面还有文章的评论功能。博客的文章详情页面与博客的首页的页头是一样的，所以为了以后便于维护，就将两个页面的页头给分离出来作为一个单独的模块 header.ejs 然后在两个页面中引入该页头模块。博客的文章内容详情的路由设计为 /views?contentId=XXX ，前端通过 GET 方式向后端提交需要渲染出来的内容的 id 。而 Markdown 渲染文章的内容则是通过 marked 模块来将内容渲染成相应 html 后，再在模板引擎中使用 &lt;- include() &gt; 引用。博客首页页头文件的模块在项目目录下的视图文件夹 /views/main 中新建一个 header.ejs 文件，在将 /views/main/index.ejs 中的页头部分去掉，然后在/views/main/header.ejs 中添加如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 博客首页页头模板 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;TFLIN'BLOG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页头 --&gt; &lt;header&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;TFL'BLOG&lt;/a&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;% if (!other.categoryId) {%&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;% } else {%&gt; &lt;li&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;% } %&gt; &lt;% for (let i = 0, len = other.categories.length; i &lt; len; i++) {%&gt; &lt;% if (other.categoryId === other.categories[i].id) {%&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/?categoryId=&lt;%= other.categories[i].id %&gt;\"&gt;&lt;%= other.categories[i].name %&gt;&lt;/a&gt;&lt;/li&gt; &lt;% } else {%&gt; &lt;li&gt;&lt;a href=\"/?categoryId=&lt;%= other.categories[i].id %&gt;\"&gt;&lt;%= other.categories[i].name %&gt;&lt;/a&gt;&lt;/li&gt; &lt;% } %&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/header&gt; &lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt;再在 /views/main/index.ejs 中，头部引用 header.js 模块：12&lt;!-- 引入页头 --&gt;&lt;%- include(\"header\") %&gt;然后新建一个视图文件 /views/main/views.ejs 作为内容详情的页面，内容为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"header\") %&gt;&lt;!-- 主体 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 内容部分 --&gt; &lt;div class=\"col-md-8\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;div class=\"container\"&gt; &lt;h2&gt;&lt;%= content.title %&gt;&lt;/h2&gt; &lt;p&gt; &lt;span class=\"text-info\"&gt;阅读量：&lt;%=content.views%&gt; | 时间：&lt;%=content.addTime%&gt; | 作者:&lt;%=content.author.username%&gt; | 分类:&lt;%=content.category.name%&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;%= content.description %&gt;&lt;/p&gt; &lt;hr&gt; &lt;p&gt;&lt;%= content.content %&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 登录、注册、用户面板部分 --&gt; &lt;div class=\"col-md-4\"&gt; &lt;%if (!userInfo.userid) {%&gt; &lt;!-- 登录面板 --&gt; &lt;div id=\"login\"&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"login-btn\"&gt;登录&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;没有账号？点击注册&lt;/a&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注册面板 --&gt; &lt;div id=\"reg\" class=\"hide\"&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户名称&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" name=\"username\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;输入密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;确认密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" name=\"repassword\" placeholder=\"请再次输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\" id=\"reg-btn\"&gt;注册&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;已有账号？点击登录&lt;/a&gt; &lt;!-- 警告框 --&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;%} else {%&gt; &lt;!-- 用户面板 --&gt; &lt;div id=\"user-info\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt;用户面板&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;%if (userInfo.isadmin) {%&gt; &lt;h3&gt;欢迎尊贵的管理员，&lt;%=userInfo.username%&gt;!&lt;/h3&gt; &lt;p&gt; &lt;a href=\"/admin\" class=\"btn btn-primary form-control\"&gt;进入控制台&lt;/a&gt; &lt;/p&gt; &lt;%} else {%&gt; &lt;h3&gt;欢迎您，&lt;%=userInfo.username%&gt;！&lt;/h3&gt; &lt;%}%&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" id=\"logout\" class=\"btn btn-danger form-control\"&gt;注销&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%}%&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"/public/js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;其实登录和注册及用户管理面板也可以抽离出来，分成一个单独的模块进行开发。内容详情的路由在 /routes/mian.js 中处理首页的相关路由，其中页头的分类信息是两个页面所共有的，所以要使用一个中间件来处理通用的信息。将 /routes/mian.js 中的内容修改为如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 引入相关模块const express = require(\"express\");const categoryModel = require(\"../models/category\");const contentModel = require(\"../models/content\");// 引入自定义的分页渲染模块const pagination = require(\"../my_modules/pagination\");// 实例化Router对象const router = express.Router();// 定义一个变量用来存放传递给模板的其他信息let other = {};// 分类查询条件let where = {};// 处理通用数据router.use(\"/\", (req, res, next) =&gt; { // 接收前端传递过来的需要查询分类的id if (req.query.categoryId) { // 如果前端传有数据过来 other.categoryId = req.query.categoryId; where.category = req.query.categoryId; } else { // 没有则置空，以方便模板引擎判断渲染不同的面板 where = {}; other.categoryId = null; } // 从数据库中查询出分类信息 categoryModel.find({}, (err, categories) =&gt; { if (!err) { // 如果不出错 other.categories = categories; } else { throw err; } }); // 继续向下一个中间件走 next();});// 首页路由配置router.get(\"/\", (req, res) =&gt; { // 调用分页渲染模块渲染内容 pagination({ // 每页显示的条数 limit: 10, // 需要操作的数据库模型 model: contentModel, // 需要控制分页的url url: \"/\", // 渲染的模板页面 ejs: \"main/index\", // 查询的条件 where: where, // 给模板绑定参数的名称 res: res, req: req, populate: [\"category\", \"author\"], // 其他数据 other: other });});// 内容页面router.get(\"/views\", (req, res) =&gt; { // 获取文章id let contentId = req.query.contentId; // 根据id从数据库中查询文章内容 contentModel.findById(contentId).populate([\"category\", \"author\"]).then((content) =&gt; { // 渲染内容模板 res.render(\"main/views\", { userInfo: req.userInfo, other: other, content: content }); // 阅读量增加 content.views ++; content.save(); });});// 将其暴露给外部使用module.exports = router;内容详情的测试此时，重启服务器，刷新客户端，往数据库中添加几条文章内容进行测试：使用 Markdown 语法渲染文章内容在 Node.js 中一般有两个模块可以解析 Markdown ，一个是 Markdown 模块，还有一个是 Marked 模块，在这个博客项目中，我选用的是 Marked 模块。Marked 是一个 Markdown 解析、编译器，使用 marked.setOptions() 传入一个对象，进行配置，参数如下:12345678910111213-o, –output [output]: 指定输出文件，默认为当前控制台-i, –input [input]: 指定输入文件或最后一个参数，默认为当前控制台输入-t, –tokens: 输出token流代替HTML–pedantic: 只解析符合markdown.pl定义的，不修正markdown的错误–gfm: 启动Github样式的Markdown–breaks: 支持Github换行符，必须打开gfm选项–tables: 支持Github表格，必须打开gfm选项–sanitize: 原始输出，忽略HTML标签–smart-lists: 优化列表输出–lang-prefix [prefix]: 设置前置样式–no-etc: 选择的反正标识–silent: 不输出错误信息-h, –help: 帮助信息更多信息请阅读官方文档 - Marked 的官方文档首先在 /routes/main.js 中引入 Marked 模块，并进行相应配置。12345678910111213const marked = require(\"marked\");// 配置markedmarked.setOptions({ renderer: new marked.Renderer(), gfm: true, tables: false, breaks: false, pedantic: false, sanitize: true, smartLists: true, smartypants: false});然后在修改 /routes/main.js 中文章内容详情的处理，在将文章内容从数据库中查询出来后通过 Marked 将 Markdown 语法渲染成 HTML 的格式后，再绑定给模板引擎去渲染。1234567891011121314151617181920// 内容页面router.get(\"/views\", (req, res) =&gt; { // 获取文章id let contentId = req.query.contentId; // 根据id从数据库中查询文章内容 contentModel.findById(contentId).populate([\"category\", \"author\"]).then((content) =&gt; { // 使用marked渲染内容成html let contentHtml = marked(content.content); // 渲染内容模板 res.render(\"main/views\", { userInfo: req.userInfo, other: other, contentHtml: contentHtml, content: content }); // 阅读量增加 content.views ++; content.save(); });});接着我们在重启服务器后，新建一篇使用 Markdown 语法所写的文章，然后进行测试：提交后去博客首页查看发现已经渲染成功","link":"/2018/08/10/Node.js + Express + mongodb 的博客项目之博客文章内容详情界面及markdown渲染内容（九）/"},{"title":"Node.js + Express + mongodb 的博客项目之后台管理界面及用户管理（五）","text":"前言前面的几篇博文中，基本实现了博客的登录注册，及区分管理员账户和普通账户。在本节中，将搭建管理员的后台管理页面，还有对注册用户的管理。后台管理页面管理员用户登录之后，可以进入后台管理页面控制台，后台管理界面的路由处理全都放在 /routes/admin.js 中，在进入后天管理界面中会有一个中间件来验证当前用户是否是管理员。首先在 app.js 中添加如下代码进行路由文件处理：12// 所有\"/admin\"的url，都由./routes/admin.js文件进行处理app.use(\"/admin\", require(\"./routes/admin.js\"));后台管理界面的静态模板在视图文件夹 /views 中新建一个 ejs 模板文件 /views/admin/index.ejs 作为后台管理界面首页。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;控制台&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/admin\"&gt;后台管理&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/admin/user\"&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 分类管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/category\"&gt;分类首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/category/add\"&gt;添加分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 内容管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/content\"&gt;内容首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/content/add\"&gt;添加内容&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav pull-right\"&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; &lt;%=userInfo.username%&gt; &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;返回主页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" id=\"logout\"&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, &lt;%=userInfo.username%&gt;&lt;/h1&gt; &lt;p&gt;欢迎进入后台管理界面&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"/admin/content/add\" role=\"button\"&gt;立即开始&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;后台路由文件此时后台的视图文件有了，我们就到 admin.js 中去渲染它，admin.js 的代码如下：123456789101112131415161718// 引入相关模块const express = require(\"express\");const userModel = require(\"../models/user\");// 实例化一个Routr对象const router = express.Router();// 后台首页路由router.get(\"/\", (req, res, next) =&gt; { // 渲染后台模板页面 console.log(\"dd\"); res.render(\"admin/index\", { userInfo: req.userInfo });});// 将其暴露给外部module.exports = router;然后重启服务器，前往浏览器进行测试：此时虽然可以进入管理员界面，但并没有对用户的身份进行相应的验证，非管理员的用户也可以在地址栏中输入 /admin 进入后台管理界面如果所示：所以我们要对用户的身份进行验证，非管理员的用户不允许访问 /admin 相关的路由，在路由文件 admin.js 中添加如下代码对用户身份进行验证：1234567891011// 进行管理员验证router.use((req, res, next) =&gt; { if (req.userInfo.isadmin) { // 如果当前登录用户是管理员 // 则继续向下一个中间件执行 next(); } else { // 不是管理员 res.render(\"无权限！\"); }});重启服务器进行验证：到此，由管理员进入后台界面的部分就基本上处理完了。用户管理用户管理主要就是在服务器查询出所有用户的信息，然后在将数据发送给前端去进行相应的展示。在本项目中，用户管理界面界面的路由设计为 GET /admin/user ，目前功能设计就将数据库中所有注册的用户信息展示出来，并未对其进行更多的更能设计，后续会对其增加增删改功能的实现。在 /routes/admin.js 中添加用户管理的路由：12345678910111213141516// 用户管理首页router.get(\"/user\", (req, res, next) =&gt; { // 从数据库中查询所有注册用户 userModel.find({}, (err, users) =&gt; { if (!err) { // 渲染用户管理模板 res.render(\"admin/user/index\", { userInfo: req.userInfo, users: users }); } else { // 抛出错误 throw err; } });});然后新建一个用户管理的 ejs 模板文件 /views/user/index.ejs 当做用户管理界面：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;控制台&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/admin\"&gt;后台管理&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/admin/user\"&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 分类管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/category\"&gt;分类首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/category/add\"&gt;添加分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 内容管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/content\"&gt;内容首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/content/add\"&gt;添加内容&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav pull-right\"&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; &lt;%=userInfo.username%&gt; &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;返回主页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" id=\"logout\"&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, &lt;%=userInfo.username%&gt;&lt;/h1&gt; &lt;p&gt;欢迎进入后台管理界面&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"/admin/content/add\" role=\"button\"&gt;立即开始&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;重启服务器进入浏览器中管理员账户登陆过后点击用户管理进行测试，发现测试所有的注册用户都已经展示出来了","link":"/2018/07/29/Node.js + Express + mongodb 的博客项目之后台管理界面及用户管理（五）/"},{"title":"谈谈原生 Ajax","text":"前言之前写 Ajax 交互，都是使用已经封装好的库，今天就来聊聊原生的 Ajax。 Ajax 就是 Asynchronous JavaScript + XML 的简写，这一技术能向服务器请求额外的数据而无需重载页面。也就是用户无需刷新页面，便能从服务器获取数据的更新，这样能使用户得到更好的体验。比如有时候，会有这样的一个需求：只想要改变页面的某个区域。而以前的技术只能通过刷新页面来实现，向服务器重新请求页面，这样会增加多余的一些请求，从而影响性能。而 Ajax 则是为了解决这一问题诞生的，是网页无需刷新页面，使用 JavaScript 与服务器进行交互的一种技术。XMLHttpRequest 对象Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR），XHR 为向服务器发送请求和解析服务器的响应提供了相当流畅的接口。IE7+、 Firefox、 Opera、 Chrome 和 Safari 都支持原生的 XHR 对象，在这些浏览器中创建 XHR 对象只需 new 一下即可。1let xhr = new XMLHttpResquest()当然，如果在更早的 IE 版本（可恶）中使用 XHR，就需要自定义一个创建 XHR 对象的方法了，同时在 IE11 之前也不能使用 ES6 的语法，所以就如同下面这般，先判断 XHR 是否存在：12345678910function createXHR() { // IE7+、Firefox、 Opera、 Chrome 和 Safari··· if (window.XMLHttpRequset) { return new XMLHttpRequset() } else { // 兼容IE5、IE6 return new ActiveXObject('Microsoft.XMLHTTP') }}var XHR = createXHR()XHR 的用法open() 方法：在使用 XHR 时，第一个调用的方法就是 open(method, url, async)，该方法接受三个参数：第一个就是发送的请求的类型如 GET 、POST 等，第二个则是提交的 url，第三个为是否异步发送的布尔值，默认为 true。如1xhr.open('GET', '/api/login', false)这行代码会启动一个针对 /api/login 的 GET 的请求，以同步的方式执行，不过调用 open() 并不会真正的去发送一个请求，而是启动一个请求准备发送。send() 方法要想真正的发送一个请求就得调用 send(String) 方法，该方法接受一个参数，即请求主题发送的数据。在红宝石一书中提到过：如果不需要通过请求主体发送数据，则必须传入 null ，因为这个参数对有些浏览器来说是必需的。如12xhr.open('GET', 'test.txt', false)xhr.send(null)响应数据收到服务器响应后，响应会自动填充为 XHR 对象的属性，相关属性为下表：属性名说明responseText作为响应主体被返回的文本responseXML如果响应的内容类型是 XML，这个属性中将保存包含着响应数据的 XML DOM 文档。对于非 XML 数据而言， responseXML 属性的值将为 nullstatus响应的 HTTP 状态statusTextHTTP 状态的说明在接受响应后，首先要检查的是 status 属性，以确保相应已经成功返回。一般是将 HTTP 状态码 200 作为请求成功的标志，不过状态码为 304 意味着请求的资源没有被修改，可以直接使用浏览器缓存的版本，所以 304 也表示请求成功。请求成功以后 responseText 属性的内容就已经准备就绪了。如12345678xhr.open('GET', 'test.txt', false)xhr.send(null)if (xhr.status === 200 || xhr.status === 304) { console.log(xhr.responseText)} else { console.log('请求出错，状态码为：' + xhr.status)}onreadystatechange 事件与 readyState 属性XHR 对象的 readyState 属性是表示当前 请求/响应 的状态，该属性的值及说明为下表：值描述0未初始化，尚未调用 open() 方法1启动，已经调用 open()方法，但尚未调用 send()方法2发送，已经调用 send()方法，但尚未接收到响应3接收，已经接收到部分响应数据4完成，已经接收到全部响应数据，而且已经可以在客户端使用了每当 readyState 属性的值发生改变的时候，会触发一次 readystatechange 事件。也就是说，我们可以通过 readystatechange 事件来监听 readyState 属性的值。当 readyState 的值为 4 的时候，说明整个过程已经完成，就可以继续进行后续的数据处理。如123456789101112let xhr = new XMLHttpRequest()xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { if (xhr.status === 200 || xhr.status === 304) { console.log(xhr.responseText) } else { console.log('请求出错，状态码为：' + xhr.status) } }}xhr.open('GET', '/api/xxx')xhr.send(null)在调用 open() 之前指定 onreadystatechange 事件处理程序和使用 xhr 而不是 this 是为了保存浏览器的兼容性。setRequestHeader() 、getResponseHeader() 与 getAllResponseHeaders() 方法setRequestHeader() 方法可以设置自定义的 HTTP 请求头部信息，该方法接受两个参数：第一个为头部字段的名称，第二个为头部字段的值。必须在 open() 和 send() 之间调用才能成功发送头部信息。如123xhr.open('GET', '/api/xxx')xhr.setRequestHeader('MyHeader', 'MyValue')xhr.send(null)getResponseHeader(“String”) 方法接受一个参数，传入头部字段名称，可以取得相应的响应头部信息。getAllResponseHeaders() 方法则可以取得一个包含所有头部信息的长字符串。如12let myHeader = xhr.getResponseHeader('MyHeader')let allHeaders = xhr.getAllResponseHeaders()GET 请求GET 是最常见的请求类型，一般用于查询某些信息。原生 Ajax 处理如下12345678910111213141516171819202122// 1.创建 XHR 对象let xhr = new XMLHttpRequest()// 4.注册事件 onreadystatechange ，readyState 属性状态改变就会调用xhr.onreadystatechange = () =&gt; { // 监听 readyState 的值 if (xhr.readyState === 4) { if (xhr.status === 200 || xhr.status === 304) { // 5.如果进到这里，说明请求与响应完成，可以继续进行其他处理 console.log(xhr.responseText) } else { // 其他问题 console.log('请求出错，状态码为：' + xhr.status) } }}// 2.启动一个请求，url最好使用 encodeURI 处理一下，以防出现乱码xhr.open('GET', url)// 3.发送请求xhr.send(null)POST 请求POST 请求使用频率仅此于 GET，一般用于向服务器发送需要保存的数据。POST 请求是将数据作为请求主体来提交，这点不同于 GET 。POST 请求的主体可以包含很多的数据，并且格式不限。如1234567891011121314151617181920212223242526// 1.创建 XHR 对象let xhr = new XMLHttpRequest()// 4.注册事件 onreadystatechange ，readyState 属性状态改变就会调用xhr.onreadystatechange = () =&gt; { // 监听 readyState 的值 if (xhr.readyState === 4) { if (xhr.status === 200 || xhr.status === 304) { // 3.如果进到这里，说明请求与响应完成，可以继续进行其他处理 console.log(xhr.responseText) } else { // 其他问题 console.log('请求出错，状态码为：' + xhr.status) } }}// 2.启动一个请求，并设置请求地址xhr.open('POST', '/api/xxx')// post方式传递数据是模仿form表单传递给服务器的,要设置header头协议xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded')// 3.发送请求let info = 'username=' + 'xxx' + '&amp;email=' + 'xxx'xhr.send(info)封装 Ajax不过不能每次使用都要这样啰嗦一堆，所以我在这里将 Ajax 进行封装。既然进行了封装，就说明以后可能会用得到，所以就要保证浏览器兼容性，同时采用 ES5 的语法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * 封装原生 Ajax * * 参数说明： * options = { * url 提交请求的url * type 请求的类型，默认为GET * data 请求体的数据 * async 是否以异步方式进行，默认为true * success 成功后的处理方法 * error 失败后的处理方法 * } * */function ajax(options) { // 传入默认为对象 var options = options || {} // 请求类型默认为 GET options.type = options.type.toUpperCase() || 'GET' // 默认为异步请求 options.async = options.async || true // 格式化参数的函数 var getParams = function (data) { var arr = [] for (param in data) { //查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码 arr.push( encodeURIComponent(param) + '=' + encodeURIComponent(data[param]) ) } // 在 url 末尾加上一个随机数，避免相同值使用 IE 缓存 arr.push(('randomNum=' + Math.random()).replace('.', '')) // 返回带有 &amp; 的查询字符串 return arr.join('&amp;') } // 格式化数据 var params = getParams(options.data) /* * 创建 XHR 对象 * 兼容 IE5、IE6 */ var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP') // 为 xhr 注册事件 onreadystatechange ，当 readyState 属性状态改变就会触发该事件 xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (xhr.status === 200 || xhr.status === 304) { // 成功 options.success &amp;&amp; options.success(xhr.responseText) } else { // 失败 options.error &amp;&amp; options.fail(status) } } } // GET 请求 if (options.type === 'GET') { // 启动 GET 一个请求，并设置请求地址 xhr.open('GET', options.url + '?' + params, options.async) // 发送请求 xhr.send(null) } else if (options.type === 'POST') { // POST 请求 xhr.open('POST', options.url, options.async) // 设置请求头，模拟 POST 表单提交 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') // 发送请求 xhr.send(param) }}测试：使用 Node.js 创建服务器，对上面的代码进行简单的测试服务器端代码如下：123456789101112131415const http = require(&apos;http&apos;)const url = require(&apos;url&apos;)const server = http.createServer((req, res) =&gt; { // GET 处理 let data = url.parse(req.url, true).query res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;, &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos; }) res.write(&apos;姓名:&apos; + data.name + &apos;===&apos; + &apos;年龄:&apos; + data.age) res.end()})server.listen(8080)客户端代码如下：1234567891011121314151617// 测试ajax({ url: 'http://localhost:8080/', type: 'GET', data: { name: 'tflin', age: '21' }, async: true, success: result =&gt; { console.log('发送成功！') console.log(result) }, error: result =&gt; { console.log('发送失败！') }})启动服务器后，刷新客户端总结Ajax 是无需等待页面就能从服务器获取数据的一种方法。Ajax 的核心对象是 XMLHttpRequest 对象，简称 XHR 对象POST 请求需要设置请求头，模拟表单提交在请求体数据后面加上时间戳或随机数，是为了避免发送相同的数据时 IE 使用缓存使用 Ajax 的的步骤为下：123451. 创建 XHR 对象2. 调用 open() 启动一个请求3. 调用 send() 发送请求4. 为 xhr 注册 onreadystatechange 时间，监听 readyState 属性的状态(这一步写在 open() 之前，保证浏览器兼容性)5. readyState 为 4，status 没什么问题时，说明整个 请求/响应 的过程已经成功","link":"/2018/08/25/谈谈原生 Ajax/"},{"title":"Node.js + Express + mongodb 的博客项目之前端ejs模块化及博客分类管理、分页功能实现（六）","text":"前言模块化开发，主要是以提高代码的复用性，可维护性等。再这个博客项目中，到处体现有模块化开发的思想，如使用 MVC 的设计模式，路由的分文件处理等。在 ejs 模板引擎中，类似 jsp 一般可以将里面的各个内容分成不同的模块，然后再分别引入相关模块组成页面，这样一来就可以做到了代码的复用性，同时维护起来的成本也降低。ejs 模板引擎的模块化在 /views/admin 中新建一个名为 header.ejs 的模板，当做后台管理的页头，将 /views/admin/index.ejs 的导航部分剪切出来放到 header.ejs 中，header.ejs 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;控制台&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/admin\"&gt;后台管理&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/admin/user\"&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 分类管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/category\"&gt;分类首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/category/add\"&gt;添加分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; 内容管理 &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/admin/content\"&gt;内容首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/content/add\"&gt;添加内容&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav pull-right\"&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt; &lt;%=userInfo.username%&gt; &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;返回主页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" id=\"logout\"&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 管理员登出 $(\"#logout\").on(\"click\", function() { $.ajax({ url: \"/api/user/logout\", success: function(result) { if (result) { window.location = \"http://localhost:8080/\"; } } }); }); &lt;/script&gt;然后在后台首页界面中引用 header.ejs 模板：123&lt;!-- 引用页头文件 --&gt; &lt;%- include(\"header\") %&gt; &lt;!-- 以前的内容在下面 --&gt;同时用户管理页面将 header 标签的内容删掉后引入 header.ejs：123&lt;!-- 引用页头文件 --&gt; &lt;%- include(\"../header\") %&gt;&lt;!-- 以前的内容在下面 --&gt;内容显示分页的实现分页功能是数据展示必备的功能，如果需要查询 1000 条数据，一次性的进行展示不仅浪费用户等待的时间，宽带，而且还占用服务器的 I/O 时间从而影响性能，用户一次性看到这么多的数据也很头疼，用户体验不好。所以就需要分页功能来展示数据，就像看书一样，一页展示一点数据，分页展示。前端组件分页功能估计后面需要经常用到，所以我们就将它抽离出来分成一个组件，一个模块。在 /views/ 目录下新建一个模板文件 pagination.ejs 当做分页组件，代码如下：123456789&lt;nav aria-label=\"...\"&gt;&lt;ul class=\"pager\"&gt; &lt;li&gt;&lt;a href=\"/admin/user?page=&lt;%=page-1%&gt;\"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; 一共有 &lt;%=count%&gt; 条数据，每页显示 &lt;%=limit%&gt; 条数据，当前第 &lt;%=page%&gt;/&lt;%=pages%&gt; 页 &lt;/li&gt; &lt;li&gt;&lt;a href=\"&lt;%=url%&gt;?page=&lt;%=page+1%&gt;\"&gt;下一页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;后端模块前端通过 GET 的方式向后端提交当前所在的页数，后端进行相应的相应。在 mongoose 中，可以通过 skip() 跳过需要查询的数据条数，limit() 每次查询几条数据，sort() 排序，等方法进行相应的组合达到分页的效果。同样，分页功能以后会在很多地方使用，所以将其写成一个独立的模块，以便以后重复的使用。在项目的根目录下新建一个目录 my_modules 用来存放我们自己编写的相应模块，在该目录下新建一个 pagination.js 文件，添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 自定义分页渲染模块 需要传递一个对象进来，该对象的属性包括： pagination = { // 每页显示的条数 limit: 10, // 需要操作的数据库模型 model: userModel, // 需要控制分页的url url: \"/admin/user\", // 渲染的模板页面 ejs: \"admin/user\", res: res, req: req, // 查询的条件 where: {}, // 联合查询的条件 populate: [] // 名称 docs }*/const pagination = (object) =&gt; { /* 实现分页 limit(Number): 限制获取的数据条数 skip(Numer): 跳过数据的条数 每页显示2条 */ // 当前页数,使用get获取前端传递的当前页数 let page = object.req.query.page || 1; // 每页显示数据条数默认为10 let limit = object.limit || 10; // 总页数 let pages = 0; // 跨集合查询的条件 let populate = object.populate || []; // 查询该文档的数据条数 object.model.countDocuments(object.where).then((count) =&gt; { // 根据总条数计算总页数 pages = Math.ceil(count / limit); // 限制当前页数，避免溢出 // page不能超过pages page = Math.min(page, pages); // page不能小于1 page = Math.max(page, 1); // 跳过数据的条数 let skip = (page - 1) * limit; // 分页查询出数据 object.model.find(object.where).populate(populate).skip(skip).limit(limit).then((docs) =&gt; { object.res.render(object.ejs, { userInfo: object.req.userInfo, docs: docs, page: page, pages: pages, limit: limit, url: object.url, count: count }); }); });};// 暴露给外部使用module.exports = pagination;自定义的分页模块完成后，在需要调用的地方引入它。在后台管理的路由文件 admin.js 中的用户管理首页中，将其代码修改为如下代码：123456789101112131415161718// 用户管理首页router.get(\"/user\", (req, res, next) =&gt; { // 调用自定义的分页渲染方法 pagination({ // 每页显示的条数 limit: 10, // 需要操作的数据库模型 model: userModel, // 需要控制分页的url url: \"/admin/user\", // 渲染的模板页面 ejs: \"admin/user\", // 查询的条件 where: {}, res: res, req: req });});然后给数据库添加多添加几条用户数据，重启服务器进行进入客户端刷新进行测试：到此用户分页管理，暂时完成。博客的分类管理博客的分类管理主要是对博客的分类进行添加，修改和删除等。管理员用户在控制台进行相应的操作，服务器端则将对数据库进行相应的操作。分类的数据结构先创建博客文章分类在 mongodb 中的存储结构，在 schemas 中新建一个文件 categories.js 用来限制文章分类的数据结构，其代码如下：123456789101112// 引入相关模块const mongoose = require(\"mongoose\");/* 文章分类的数据结构 { 文章标题，字符串类型 }*/module.exports = new mongoose.Schema({ name: String});创建了分类的Schema对象后，我们通过Schema对象来创建文章分类的数据模型，通过数据模型来对数据库进行相应的操作。在 models 文件夹中新建一个 category.js 来当做文章分类的模型，在 category.js 中添加如下代码：1234567// 引入mongoose模块const mongoose = require(\"mongoose\");// 引入文章分类的schemaconst categoriesSchema = require(\"../schemas/categories\");// 创建文章分类模型module.exports = mongoose.model(\"category\", categoriesSchema);分类管理首页在文章分类的模型创建完毕后，就可以创建分类管理的首页了,分类管理首页的路由设计为 GET /admin/crtegory 。我们新建一个分类管理首页的视图文件，在 /views/admin 目录下，新建一个 /categroy/index.ejs 的文件，内容如下：12345678910111213141516171819202122232425262728293031323334&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;分类首页&lt;/li&gt; &lt;/ol&gt; &lt;table class=\"table table-hover table-striped table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;%for(let i = 0, len = docs.length; i &lt; len; i++){%&gt; &lt;tr&gt; &lt;td&gt;&lt;%=docs[i]._id%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=docs[i].name%&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/admin/category/edit?id=&lt;%=docs[i]._id%&gt;\" class=\"btn btn-default\"&gt;修改&lt;/a&gt; &lt;a href=\"/admin/category/delete?id=&lt;%=docs[i]._id%&gt;\" class=\"btn btn-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;%}%&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;!-- 引入分页模板 --&gt;&lt;%- include(\"../../pagination\") %&gt;&lt;/body&gt;&lt;/html&gt;重启服务器刷新浏览器客户端，进入后台管理首页，点击分类管理：分类管理的添加新建一个文章分类添加的页面 /views/admin/category/add.ejs 并添加如下内容：12345678910111213141516171819&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/category\"&gt;分类首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;分类添加&lt;/li&gt; &lt;/ol&gt; &lt;form method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;分类名称&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" placeholder=\"请输入分类名称\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;同时在后台路由文件 routes/admin.js 中对其进行路由配置，分类添加的界面路由为 GET /admin/categorry/add 添加如下代码：1234567// 分类添加的首页router.get(&quot;/category/add&quot;, (req, res, next) =&gt; { // 渲染分类添加模板 res.render(&quot;admin/category/add&quot;, { userInfo: req.userInfo });});此时，添加文章的页面已经被渲染出来了，但是我们并没有编写保存的处理。前端使用 POST 方式向服务器提交数据，在后台进行相应的验证后，若不出错则保存进入数据库中。但在此之前，我们需要一个提示的界面，以此来提示用户相应的信息。在 /views/admin 中新建一个 error.ejs 和 success.ejs 分别用来提示用户操作的成功与失败。error.ejs：12345678910111213141516171819202122232425&lt;%- include('header') %&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;错误提示&lt;/li&gt; &lt;/ol&gt; &lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;错误提示&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;%=message%&gt; &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; &lt;%if(url){%&gt; &lt;a href=\"&lt;%=url%&gt;\"&gt;跳转&lt;/a&gt; &lt;%}else{%&gt; &lt;a href=\"javascript:window.history.back();\"&gt;返回上一步&lt;/a&gt; &lt;%}%&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;success.ejs:12345678910111213141516171819202122232425&lt;%- include('header') %&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;成功提示&lt;/li&gt; &lt;/ol&gt; &lt;div class=\"panel panel-success\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;成功提示&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;%=message%&gt; &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; &lt;%if(url){%&gt; &lt;a href=\"&lt;%=url%&gt;\"&gt;跳转&lt;/a&gt; &lt;%}else{%&gt; &lt;a href=\"javascript:window.history.back();\"&gt;返回上一步&lt;/a&gt; &lt;%}%&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;最后我们再 /routes/admin.js 中添加如下代码，对前面添加的分类数据进行保存，保存的路由为 POST /category/add ：123456789101112131415161718192021222324252627282930313233343536373839404142434445// 分类的保存router.post(\"/category/add\", (req, res, next) =&gt; { // 获取分类名称，默认为\"\" let name = req.body.name || \"\"; // 如果名称为空 if (name === \"\") { // 渲染一个错误提示 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"分类名称不能为空！\" }); return; } // 从数据库中查询该名称是否已存在 categoryModel.findOne({name: name}, (err, docs) =&gt; { // 如果数库库中已存在该名称 if (docs) { // 渲染一个错误提示 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"该分类名称已存在！\" }); return; } else { // 不存在则新建一个数据 categoryModel.create({ name: name }, (err) =&gt; { if (!err) { // 渲染一个错误提示 res.render(\"admin/success\", { userInfo: req.userInfo, message: \"添加成功！\", // 跳转到该路由 url: \"/admin/category\" }); return; } }); } });});最后重启服务器进行测试：分类的添加完成。分类管理的修改及删除分类的修改是通过 GET 方式将需要修改的分类提交到服务器，然后服务器渲染出其修改的界面，管理员再对该数据进行相应的修改。在 /views/admin/category 目录下新建一个 ejs 模板，分类修改的界面，内容如下：12345678910111213141516171819&lt;!-- 引入页头模板 --&gt;&lt;%- include(\"../header\") %&gt;&lt;!-- 内容 --&gt;&lt;div class=\"container-fluid\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"/admin\"&gt;管理首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/admin/category\"&gt;分类首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;分类修改&lt;/li&gt; &lt;/ol&gt; &lt;form method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;请输入新名称&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" placeholder=\"请输入分类名称\" value=\"&lt;%=category.name%&gt;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;接着在后台管理的路由文件 admin.js 中添加分类修改的路由 GET /admin/category/edit 处理，添加代码如下：12345678910111213141516171819202122// 分类的修改界面router.get(\"/category/edit\", (req, res, next) =&gt; { // 获取用户提交过来的id let id = req.query.id || \"\"; // 根据id从数据库中查询相关数据 categoryModel.findOne({_id: id}, (err, category) =&gt; { if (category) { // 如何数据存在则渲染修改界面 res.render(\"admin/category/edit\", { userInfo: req.userInfo, category: category }); } else { // 若不存在渲染错误提示面板 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"该分类不存在！\" }); } });});修改界面的路由完成之后，我们再写分类修改的保存，修改的保存是以 POST 的方式向服务器提交数据。在 admin.js 中添加如下代码处理前端提交过来的数据进行保存：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 分类修改的保存router.post(\"/category/edit\", (req, res, next) =&gt; { // 获取修改后的id及名称 let id = req.query.id; let name = req.body.name; // 根据id从数据库中查询相关数据 categoryModel.findById(id, (err, category) =&gt; { if (category) { // 若数据存在 // 简单验证---如果数据没修改 if (name === category.name) { res.render(\"admin/success\", { url: \"/admin/category\", userInfo: req.userInfo, message: \"修改成功！\" }); return; } // 查询用户修改的分类是否与数据库中的冲突 categoryModel.findOne({ _id: {$ne: id}, name: name }, (err, docs) =&gt; { if (docs) { // 数据冲突 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"该分类已存在！\" }); return; } else { // 更新数据 categoryModel.update({_id: id}, {$set: {name: name}}, (err) =&gt; { if (!err) { // 不出错 res.render(\"admin/success\", { userInfo: req.userInfo, url: \"/admin/category\", message: \"修改成功！\" }); return; } else { // 出错 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"修改失败！\" }); return; } }); } }); } else { // 若不存在 res.render(\"admin/error\", { userInfo: req.userInfo, url: null, message: \"该分类不存在！\" }); return; } });});分类的删除同样也是通过 GET 方式将需要删除分类的 id 提交到服务器进行数据库删除，分类删除的路由设计为 GET /admin/category/delete 。在 admin.js 添加如下代码，处理删除分类逻辑：1234567891011121314151617181920212223// 分类的删除router.get(\"/category/delete\", (req, res, next) =&gt; { // 获取需要删除的分类id let id = req.query.id || \"\"; // 从数据库中删除数据 categoryModel.remove({_id: id}, (err) =&gt; { if (!err) { // 删除成功 res.render(\"admin/success\", { url: \"/admin/category\", userInfo: req.userInfo, message: \"删除成功！\" }); } else { // 删除失败 res.render(\"admin/error\", { url: null, userInfo: req.userInfo, message: \"删除失败！\" }); } });});最后重启服务器，在客户端中进行测试：好了，到此分类的添加，删除，修改基本上已经完成了。","link":"/2018/07/31/Node.js + Express + mongodb 的博客项目之前端ejs模块化及博客分类管理、分页功能实现（六）/"},{"title":"Node.js + Express + mongodb 的博客项目之模板引擎的配置及用户登录、注册（三）","text":"前言在这一节中，我们将会进行模板引擎的配置，以及博客前台的界面设计、并且设计博客的用户数据结构及连接数据库，实现用户的注册、登录。写得比较的详细，所以篇幅会较长，模板引擎的配置模板引擎是为了实现模板文件与业务数据的结合，实现界面与数据的分离。同时，还可以进行组件化开发，减少我们的代码量，可复用。在 Express 中配置模板引擎的过程一般如下views, 放模板文件的目录，比如： app.set(“views”, “./views”)view engine, 模板引擎，比如： app.set(“view engine”, “ejs”)一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载。在 app.js 添加代码如下：123456789// 引入路径模块const path = require(\"path\");/*配置模板引擎*/// 设置模板引擎的存放目录为当前被执行的js文件的相对目录viewsapp.set(\"views\", path.join(__dirname, \"views\"));// 设置模板引擎为ejsapp.set(\"view engine\", \"ejs\");配置完模板引擎，就可以使用模板引擎进行数据渲染了，通过 res.render() 调用其导出方法 __express(filePath, options, callback) 渲染模板。这个时候我们在 views 目录下新建一个文件 main/index.ejs 作为博客的主页123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;TFLIN'BLOG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;欢迎来到我的博客&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;接着在 app.js 文件修改为如下代码，使用 res.render() 后端渲染模板。将12345// 给app绑定路由，所有通过&quot;/&quot;的url都将通过以下方法app.get(&quot;/&quot;, (req, res, next) =&gt; { // 发送内容至客户端 res.send(&quot;&lt;h1&gt;TFL BLOG&lt;/h1&gt;&quot;);});修改为12345// 给app绑定路由，所有通过&quot;/&quot;的url都将通过以下方法app.get(&quot;/&quot;, (req, res, next) =&gt; { // 渲染admin/index模板 res.render(&quot;main/index&quot;);});这个时候，node app 启动项目，然后在浏览器中输入地址，就可以看到模板已经被渲染出来了配置服务器静态资源库在 Node.js 服务器中，没有其他类似其他服务器一样有个专门存放静态资源的地方，我们需要对此进行相应的配置，实现对应的功能。在原生 Node.js 中，我们实现这个过程需要考虑很多种情况，而 express 框架，用 express.static 一行代码就可以达到目的了。在 app.js 添加如下代码，配置服务器静态资源库12// 使用中间件设置静态资源库的目录app.use(&quot;/public&quot;, express.static(path.join(__dirname, &quot;/public&quot;)));这样我们就可以在 /public 目录下存放相关的静态资源了，我们这个项目是便捷开发，所以我们先在静态资源库中存放 jQuery、Bootstrap 相关文件。我们再对 main/index.ejs 文件进行相应的内容及样式设计123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;TFLIN'BLOG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;TFL'BLOG&lt;/a&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Node.js&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/header&gt;&lt;/body&gt;&lt;/html&gt;重启服务器，再次查看浏览器看到之前我们设置的样式已经生效了，说明静态资源库设置成功。路由配置我们在实现相应的功能之前，要进行相应的路由配置，也就是实现分模块开发。在 /routes 目录下新建以下文件，用于路由配置。api.js –&gt; 提供登录，注册，登出接口main.js –&gt; 前台路由文件admin.js –&gt; 后台管理路由文件然后在 app.js 将12345// 给app绑定路由，所有通过&quot;/&quot;的url都将通过以下方法app.get(&quot;/&quot;, (req, res, next) =&gt; { // 渲染admin/index模板 res.render(&quot;main/index&quot;);});修改为以下代码，实现路由分模块处理12345/*路由处理*/// 所有通过&quot;/&quot;的url，都由./routes/main.js文件进行处理app.use(&quot;/&quot;, require(&quot;./routes/main.js&quot;));再修改 main.js 首页路由1234567891011121314// 引入相关模块const express = require(&quot;express&quot;);// 实例化Router对象const router = express.Router();// 首页路由配置router.get(&quot;/&quot;, (req, res) =&gt; { // 渲染首页模板 res.render(&quot;main/index&quot;);});// 将其暴露给外部使用module.exports = router;最后在重启服务器，测试，依旧成功！注册、登录、登出的实现前台界面设计要实现登录注册等，我们先在前端写出相应内容，然后在通过 ajax 的方式提交请求到后端。修改 main/inde.ejs 为如下，进行简单的界面设计：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!--引用bootstrap样式--&gt; &lt;link rel=\"stylesheet\" href=\"/public/css/bootstrap.min.css\"&gt; &lt;title&gt;TFLIN'BLOG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页头 --&gt; &lt;header&gt; &lt;header&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;TFL'BLOG&lt;/a&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"/\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;Node.js&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/header&gt; &lt;!-- 主体 --&gt; &lt;div class=\"container\"&gt; &lt;!-- 内容部分 --&gt; &lt;div class=\"col-md-8\"&gt; &lt;div class=\"well\"&gt; &lt;h3&gt;博客标题&lt;/h3&gt; &lt;p&gt;内容简介&lt;/p&gt; &lt;a href=\"javascript:;\" class=\"btn btn-info\"&gt;阅读全文&lt;/a&gt; &lt;span class=\"text-info pull-right\"&gt;点击量 时间 作者 分类&lt;/span&gt; &lt;/div&gt; &lt;div class=\"well\"&gt; &lt;h3&gt;博客标题&lt;/h3&gt; &lt;p&gt;内容简介&lt;/p&gt; &lt;a href=\"javascript:;\" class=\"btn btn-info\"&gt;阅读全文&lt;/a&gt; &lt;span class=\"text-info pull-right\"&gt;点击量 时间 作者 分类&lt;/span&gt; &lt;/div&gt; &lt;div class=\"well\"&gt; &lt;h3&gt;博客标题&lt;/h3&gt; &lt;p&gt;内容简介&lt;/p&gt; &lt;a href=\"javascript:;\" class=\"btn btn-info\"&gt;阅读全文&lt;/a&gt; &lt;span class=\"text-info pull-right\"&gt;点击量 时间 作者 分类&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 登录、注册、用户面板部分 --&gt; &lt;div class=\"col-md-4\"&gt; &lt;!-- 登录面板 --&gt; &lt;div id=\"login\"&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\"&gt;登录&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;没有账号？点击注册&lt;/a&gt; &lt;!-- 警告框 --&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 注册面板 --&gt; &lt;div id=\"reg\"&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;用户名称&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;输入密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-addon\"&gt;确认密码&lt;/span&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"请再次输入密码\"&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-primary form-control\"&gt;注册&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;a href=\"javascripts:;\" class=\"col-md-offset-4\"&gt;已有账号？点击登录&lt;/a&gt; &lt;!-- 警告框 --&gt; &lt;div class=\"alert alert-success alert-dismissable hide\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\"&gt;×&lt;/button&gt; &lt;span&gt;恭喜您操作成功！&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 用户面板 --&gt; &lt;div id=\"user-info\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt;用户面板&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;h3&gt;欢迎，xxx&lt;/h3&gt; &lt;p&gt; &lt;button type=\"button\" name=\"button\" class=\"btn btn-danger form-control\"&gt;注销&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"/public/js/3.3.1-jquery-min.js\"&gt;&lt;/script&gt; &lt;script src=\"/public/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/html&gt;在浏览器中刷新，效果如下：用户表结构的设计及连接数据库在写用户模块之前，我们先对用户的表结构进行设计。在 schemas 目录下，新建一个 users.js 的文件，用来设计用户的数据结构。schemas/users.js 代码如下：12345678910111213141516171819// 引入mongoose模块，驱动mongodb数据库const mongoose = require(&quot;mongoose&quot;);/*用户的数据结构{ 用户名，字符串类型 用户密码，字符串类型 是否为管理员，布尔类型，默认为false}*/module.exports = new mongoose.Schema({ username: String, password: String, isadmin: { type: Boolean, default: false }});创建完用户的 Schema 对象以后，我们在 models 中创建用户模型，通过用户模型类操作数据库.models/user.js 代码如下：1234567// 引入mongoose模块const mongoose = require(&quot;mongoose&quot;);// 引入user的schemaconst userSchema = require(&quot;../schemas/users.js&quot;);// 创建user对象模型，并暴露出去module.exports = mongoose.model(&quot;user&quot;, userSchema);然后我们在项目入口文件 app.js 进行数据库连接，再引入 mongoose 模块后，将 app.js 中监听端口号的部分改为：1234567891011// 连接数据库mongoose.connect(&quot;mongodb://localhost:27017/blog_db&quot;, (err) =&gt; { if (!err) { // 如果没出错，监听端口号 app.listen(8080); } else { // 出错则抛出异常 console.log(&quot;数据库连接成功！&quot;); throw err; }});这个时候，我们先在命令行使用 mongod 命令启动 mongodb 服务，当然也可以将该服务设置成系统服务，就不用每次都手动启动服务了。mongodb 服务启动完成后，就可以 重启服务器了，node app:可以看到，此时我们的数据库已经连接成功了。前端交互设计在写相关接口前，先把博客前台的交互简单处理一下，就是先显示登录的界面，将注册的界面给隐藏起来，由用户点击切换相关面板，同时通过 ajax 提交数据到相关接口进行处理。我们先把用户注册面板和用户信息面板隐藏起来，在 views/main/index.ejs 中给它们加上一个 .hide 的 class。在 /public/js 目录下新建一个 main.js 用于处理博客首页的相关交互，main.js 的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243$(() =&gt; { // 获取点击注册的连接 const $regLink = $(\"#login a\"); // 获取点击登录的连接 const $loginLink = $(\"#reg a\"); // 获取登录的div const $loginDiv = $(\"#login\"); // 获取注册的div const $regDiv = $(\"#reg\"); // 获取登录按钮 const $loginBtn = $(\"#login-btn\"); // 获取注册按钮 const $regBtn = $(\"#reg-btn\"); // 获取警告框 const $warningBox = $(\".alert\"); // 切换到登录/注册界面的方法 (() =&gt; { // 注册点击事件 $regLink.on(\"click\", () =&gt; { // 隐藏登录界面 $loginDiv.hide(); // 显示注册界面 $regDiv.removeClass(\"hide\"); $regDiv.addClass(\"show\"); }); // 注册点击事件 $loginLink.on(\"click\", () =&gt; { // 隐藏注册界面 $regDiv.hide(); $regDiv.removeClass(\"show\"); // 显示登录界面 $loginDiv.show(); }); })(); // 警告框的关闭 (() =&gt; { $(\"button[class='close']\").bind(\"click\", (e) =&gt; { $warningBox.addClass(\"hide\"); }); })();});这样我们就可以得到一个简答的交互效果，如下图用户注册的接口博客的相关接口我们在 api.js 文件中写，在 api.js 中，我们先定义一个返回给前端的 json 数据，里面包含有请求的状态码，以及返回的提示消息。而前端的登录与注册是通过 ajax 与后端进行相应的交互，所以我们通过 POST 的方式请求。我们想要获取解析前端通过 POST 提交的数据，就需要 Express 的一个中间模块 body-parser 。body-parser 提供了 bodyParser.json(), bodyParser.raw(), bodyParser.text(), bodyParser.urlencoded() 四种解析数据的方法，其中 bodyParser.urlencoded() 支持utf-8 的解析方式。该方法提供了多个参数，而我们用到的是 extended ，当 extended 的值为 false 的时候会使用 querystring 来解析 url 格式的数据，值为 true 则会以 qs 库来解析，默认为 true。这里有一篇文章对该中间件进行了讲解，可以去看看 –&gt; Express 中间件—-body-parser我们在 app.js 中添加如下代码对 body-parser 进行相应的配置：12345678910// 引入body-parser模块const bodyParser = require(&quot;body-parser&quot;);// body-parser配置app.use(bodyParser.urlencoded({extended: true}))// 注意：中间件要写在路由配置前，否则容易出错// 所有通过&quot;/api&quot;的url，都由./routes/api.js文件进行处理app.use(&quot;/api&quot;, require(&quot;./routes/api.js&quot;));配置完 body-parser 后我们就可以使用 req.body 来获取前端传过来的post信息。接下来在 api.js 中添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 引入相关模块const express = require(&quot;express&quot;);// 引入用户数据模型，进行相应的操作const userModel = require(&quot;../models/user&quot;);// 实例化Router对象const router = express.Router();// 定义一个返回给前端的消息对象let responseData;// 通过中间件对其进行初始化，这样每一次请求都会进行初始化router.use((req, res, next) =&gt; { responseData = { // 状态码 code: 0, // 返回的消息 message: &quot;&quot; }; next();});/* 用户注册的接口： 提交的验证： 1.用户名不能为空 2.密码不能为空 3.两次密码必须一致 数据库验证： 1.用户名是否已存在*/router.post(&quot;/user/register&quot;, (req, res, next) =&gt; { // 用户名 let username = req.body.username; // 密码 let password = req.body.password; // 确认密码 let repassword = req.body.repassword; // 用户名不能为空 if (username === &quot;&quot;) { // 设置数据 responseData.code = 1; responseData.message = &quot;用户名不能为空！&quot;; // 给客户端发送一个json的相应 res.json(responseData); return; } // 密码不能为空 if (password === &quot;&quot; || repassword === &quot;&quot;) { responseData.code = 2; responseData.message = &quot;密码或确认密码不能为空！&quot;; res.json(responseData); return; } // 两次密码必须一致 if (password !== repassword) { responseData.code = 3; responseData.message = &quot;两次密码不一致！&quot;; res.json(responseData); return; } // 向数据库中查询用户名是否已存在 userModel.findOne({username: username}, (err, user) =&gt; { // 如果用户名已存在 if (user) { responseData.code = 4; responseData.message = &quot;该用户名已存在！&quot;; res.json(responseData); return; } else { // 用户名不存在，则新建用户 userModel.create({ username: username, password: password }, (err) =&gt; { if (!err) { responseData.message = &quot;注册成功！&quot;; res.json(responseData); } else { console.log(err); } }); } });});// 将其暴露给外部module.exports = router;此时后台的用户注册接口已经写好了，我们在前端通过 ajax 去请求该接口，在博客首页的 js 文件 public/js/main.js 中添加如下代码：12345678910111213141516171819202122232425262728// ajax请求 (() =&gt; { // 用户注册 $regBtn.on(\"click\", () =&gt; { // 通过ajax提交数据 $.ajax({ type: \"post\", url: \"/api/user/register\", data: { username: $(\"#reg [name='username']\").val(), password: $(\"#reg [name='password']\").val(), repassword: $(\"#reg [name='repassword']\").val() }, dataType: \"json\", success: (result) =&gt; { if (result.code) { $warningBox.find(\"span\").html(\"警告：\" + result.message); $warningBox.addClass(\"alert-danger\") $warningBox.removeClass(\"hide alert-success\"); } else { $warningBox.find(\"span\").html(\"恭喜您\" + result.message); $warningBox.addClass(\"alert-success\") $warningBox.removeClass(\"hide alert-danger\"); } } }); }); })();后端的用户注册接口已经写完了，前端的 ajax 请求也写完了，我们就可以重启服务器进行测试了，我们先在数据库中新建一个用户叫 admin 以便进行用户名冲突测试，使用 node app 重启服务器，在客户端中刷新网页，进行测试：前端和服务器方面没有问题，我们再到数据库中看看，发现新注册的用户已经存入数据库中了到这里用户注册算是基本完成了。用户登录的接口用户登录的实现基本上和用户注册的逻辑差不多，前端 ajax 提交数据到后端，后端进行相应的验证，并将验证结果返回给前端。后端的登录接口设计为 POST api/user/login。在 routes/api.js 文件中添加如下代码，实现登录接口：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 用户登录的接口 提交的验证： 1.用户名不能为空 2.密码不能为空 数据库的验证： 1.用户名是否存在 2.若存在密码是否正确*/router.post(\"/user/login\", (req, res, next) =&gt; { // 用户名 let username = req.body.username; // 密码 let password = req.body.password; // 用户名不能为空 if (username === \"\") { responseData.code = 1; responseData.message = \"用户名不能为空！\"; res.json(responseData); return; } // 密码不能为空 if (password === \"\") { responseData.code = 2; responseData.message = \"密码不能为空！\"; res.json(responseData); return; } // 向数据库查询，用户是否存在 userModel.findOne({username: username}, (err, user) =&gt; { // 如果存在该用户 if (user) { // 验证密码是否正确 if (user.password === password) { responseData.message = \"登录成功！\"; res.json(responseData); return; } else { responseData.code = 5; responseData.message = \"密码不正确！\"; res.json(responseData); return; } } else { responseData.code = 6; responseData.message = \"该用户名不存在！\"; res.json(responseData); return; } });});后端的登录接口完成后，我们在前端的 Js 代码中使用 ajax 向该接口提交数据public/js/main.js 的 ajax 请求方法中添加如下代码：123456789101112131415161718192021222324// 用户登录 $loginBtn.on(\"click\", () =&gt; { $.ajax({ type: \"post\", url: \"/api/user/login\", data: { username: $(\"#login [name='username']\").val(), password: $(\"#login [name='password']\").val() }, dataType: \"json\", success: (result) =&gt; { if (result.code) { $warningBox.find(\"span\").html(\"警告：\" + result.message); $warningBox.addClass(\"alert-danger\") $warningBox.removeClass(\"hide alert-success\"); } else { // 登录成功，隐藏登录界面 $loginDiv.hide(); // 显示用户界面 $(\"#user-info\").removeClass(\"hide\"); } } }); });重启服务器，刷新客户端，我们来进行相应的测试：没发现什么问题，此时博客的用户登录暂时完成。当然这只是简单的登录，并没有使用 cookie 来保存登录状态，保存登录状态会在下一节完成。","link":"/2018/07/23/Node.js + Express + mongodb 的博客项目之模板引擎的配置及用户登录、注册（三）/"},{"title":"浅谈 vue 前端同构框架 nuxt 及其性能优化","text":"前言使用 nuxt.js 做项目也接近快一年了，从立项到内测、公测、再到正式上线，还有后面的不断维护，也陆陆续续的踩了很多坑，其中最大的问题就是 node 的渲染性能问题了。模板转换是 cpu 密集型的操作，node 又是单线程的，并发一高，cpu 就会飙到 100% 。为了提升 nuxt.js 的渲染性能，也陆陆续续的查找了很多资料，发现网上针对 nuxt.js 的性能优化的文章比较少，比较杂。所以我写下这篇文章记录下自己对 nuxt.js 做性能优化的时候采取的一些方法，算是篇总结吧，也希望能给从谷歌搜到这的朋友一些帮助。本文着重于性能优化，对概念类的东西会一概而过。同构渲染与传统的服务端渲染，使用模板引擎生成 html 不同。前端同构渲染在服务器端和客户端运行的是同一套代码，只有首屏是服务端直出 html ，而点击路由切换则是一个单页应用(spa)。同构渲染即能做到首屏直出，又能体验到无刷新的用户体验。使用模板引擎生成 html 可以做到首屏直出 html ，但做不到 spa 应用无刷新的用户体验，不过模板引擎不限制你的服务端语言，而同构渲染因为要在客户端和服务端跑着同一套代码，所以只能使用 node.js 做渲染服务器。Nuxtnuxt.js 是 vue 的一个服务端渲染的框架，把 webpack 、vue loader，vuex, router 系列配置整合到了一起，是一个比较完整的 vue 服务端渲染的方案。生命周期ssr 在没有做缓存的情况下，客户端的每次 request 都会到 node 服务器中，触发后端渲染。渲染服务器引入 renderer 和相应的 vue 应用，根据 route 找到相应的组件和数据，拉组件再拉数据（可能是异步的），加载组件生产 DOM，然后再使用 renderToString 吐给 response。下图是来自 nuxt 官方文档的生命周期：性能优化有得必有失，vue ssr 需要在服务器根据 vue 文件生成虚拟 dom 再序列化成 html，是 cpu 密集型的操作。并且为了隔离请求不同的请求，它会为每一个请求创建一个上下文 context，这样一来，vue ssr 和传统的模板引擎相比，其性能起码差了几十倍。要想 vue ssr 经得起上线的考验，高并发的情况下能正常工作，必须要采取一系列的性能优化手段，并采取明智的部署策略。缓存但凡是提到性能优化，第一个想到的必然是缓存。node.js 是单线程的，它的高性能是相对于异步 io 操作频繁的。针对 io 密集型而非 cpu 密集型，因此需要在渲染过程中采取合理的缓存策略。ssr 的缓存可分为 组件级别的缓存、数据级别的缓存、页面级别的缓存。当命中缓存的时候，只需将缓存中的 html 吐给 response ，不用再进行一系列的渲染活动，极大的节省 cpu 资源。1. 组件的缓存nuxt 的组件级别的缓存，使用的是 Component Cache module 模块，将 @nuxtjs/component-cache 从 npm 中添加到依赖中，在配置文件 nuxt.config.js 做出如下配置：123456789101112{ modules: [ '@nuxtjs/component-cache', [ '@nuxtjs/component-cache', { max: 10000, maxAge: 1000 * 60 * 60 } ] ]}在需要缓存的组件中使用 serverCacheKey 函数来标识1234567export default { name: 'ReplyItem', serverCacheKey: props =&gt; props.postId, props: { postId: String }}serverCacheKey 函数所返回的 key 必须有足够的信息去标识该组件，返回常量将导致组件始终被缓存，这对纯静态组件是有好处的。同时，缓存的组件必须要有唯一的 name 属性。但值得注意的是，使用组件级别缓存的时候，不要缓存单一实例的组件。应该缓存的是那些重复使用的展示型组件，如 v-for 下的重复组件，在我所写的项目中，我使用组件级别的缓存也主要是这一类，如帖子列表、新闻列表、评论列表等。如果 render 在渲染组件的过程中，命中缓存，则直接使用缓存结果，所以一些情况不能使用组件级别的缓存：可能拥有依赖 global 数据的子组件。具有在渲染 context 中产生副作用的子组件。2. 数据的缓存在 node 服务器向后端请求数据的时间，也会影响到渲染的时间，所以数据层，最好也要有缓存。如果从后端 api 拉取数据的时间需要 3 秒，那这 3 秒会直接反应在首屏渲染时间上。对于数据层的缓存，应该对那些不涉及用户信息和实时性要求不高的接口进行缓存。对于数据层的缓存，使用的是 lru-cache 这个模块。示例代码:1234567891011121314151617181920212223242526272829303132333435import axios from 'axios'import LRU from 'lru-cache'import md5 from 'md5'const options = { // 最大缓个数 max: 1000, // 缓存周期 maxAge: 1000 * 60 * 5 // 5 分钟的缓存}const cache = new LRU(options)// 需要缓存数据的接口const CACHE_API = ['v1/api/xxxx', 'v1/api/xxxx', 'v1/api/xxxx', 'v1/api/xxxx']export function get(url, params) { const key = md5(url + JSON.stringify(params)) // 只在服务端进行缓存 if (process.server &amp;&amp; cache.has(key)) { // 命中缓存 return Promise.resolve(cache.get(key)) } return axios .get(url, { params }) .then(res =&gt; { // 只在服务端进行缓存 if (process.server &amp;&amp; CACHE_API.includes(url)) { cache.set(key, res.data) } return Promise.resolve(res.data) }) .catch(err =&gt; throw err)}3. 页面的缓存不是每一请求都需要触发后端渲染的，当页面不涉及用户数据，就可以对整个页面进行缓存。url 命中缓存的时候，直接将缓存吐给 response ，不再触发一系列的渲染活动。在 nuxt 中，使用页面级别的缓存，使用的是服务器渲染中间件 serverMiddleware 。在这一层的缓存中可以使用 redis 进行缓存，在 nginx 层的时候就可以直接调用 redis 吐数据，缓存过期后再重新出发 node 渲染并重新缓存。当然，也可以缓存在内存中。示例代码：根目录下新建一个 serverMiddleware/pageCache.js12345678910111213141516171819202122232425262728293031323334const LRU = require('lru-cache')const options = { max: 1000, maxAge: 1000 * 60 * 5}// 需要进行页面级别缓存的路由const CACHE_URL = ['/xxx', '/xxx', '/xxx']const cache = new LRU(options)export default function (req, res, next) { const url = req._parsedOriginalUrl const pathname = !!url.pathname ? url.pathname : '' if (CACHE_URL.includes(pathname)) { const existsHtml = cache.get(pathname) if (existsHtml) { // 不要忘了设置 Content-Type 不然浏览器有时候可能不会渲染而是触发下载文件 res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' }) return res.end(existsHtml.html, 'utf-8') } else { res.original_end = res.end res.end = function (data) { if (res.statusCode === 200) { cache.set(pathname, { html: data }) } res.original_end(data, 'utf-8') } } } next()}页面缓存渲染中间件写好之后，在配置文件 nuxt.config.js 中使用12345module.exports = { // ... serverMiddleware: ['~/serverMiddleware/pageCache.js'] // ...}不必要的渲染开销服务端渲染最主要的作用是 seo，但并不是所有的页面都需要进行 seo。整站式的 ssr 意味着将消耗巨大服务器 cpu 资源，如果只从后端渲染需要 seo 的页面，将极大的节省 cpu 资源，空余出来的 cpu 资源则作用于更大的并发量。例如：掘金 就仅仅是在文章的详情页做 ssr 。那么在 nuxt.js 中，如何根据不同的路由去觉得是进行服务端渲染或是客户端渲染呢？这一点在 nuxt.js 的官方文档中并未提到这一点，但我在 nuxt.js 的源码中找到关于 url 控制是服务度渲染还是客户端渲染的代码：nuxt.js/packages/vue-renderer/src/renderer.js123456789101112131415async renderRoute(url, renderContext = {}, _retried) { // ... if (renderContext.spa === undefined) { // TODO: Remove reading from renderContext.res in Nuxt3 renderContext.spa = !this.SSR || req.spa || (renderContext.res &amp;&amp; renderContext.res.spa); } // ... return renderContext.spa ? this.renderSPA(renderContext) : this.renderSSR(renderContext)}其中决定不同的路由是服务度渲染还是客户端渲染，取决于 renderContext.spa 的值，而 renderContext.spa 的值按先后顺序取决于 options.render.ssr 、 req.spa 、 renderContext.res.spa 。 所以我们只需要在特定的路由将 res.spa 置为 true 即可。新建渲染服务器中间件 serverMiddleware/spaPage.js:123456789101112export default function (req, res, next) { const { _parsedOriginalUrl } = req const pathname = _parsedOriginalUrl.pathname ? _parsedOriginalUrl.pathname : '' res.spa = true if (pathname.includes('/post') || pathname === '/') { res.spa = false } next()}只在文章详情页和首页进行 ssr ，在配置文件 nuxt.config.js 中使用12345module.exports = { // ... serverMiddleware: ['~/serverMiddleware/spaPage.js'] // ...}首屏最小化为了进一步的节省服务器性能，我们可以分析需要服务端渲染的页面布局。进行合理的页面结构的拆分，首屏所需的数据和页面结构在服务端获取并渲染，非首屏所需的数据和结构在客户端拉取并渲染。需要在服务端拉取的数据可以使用 asyncData 方法来异步获取数据，不需要在服务端拉取的数据在 mounted 这个钩子获取。分割结构可以使用 no-ssr 或 client-only(nuxt 版本不小于 2.9) 标签包裹不需要在服务端进行渲染的结构。使用 no-ssr 包裹不需要服务端渲染的内容：123456789101112131415161718&lt;template&gt; &lt;div class=\"post-detail\"&gt; &lt;main&gt; &lt;post-head /&gt; &lt;post-body /&gt; &lt;post-foot /&gt; &lt;/main&gt; &lt;aside&gt; &lt;!-- 不需要服务端渲染的内容 --&gt; &lt;no-ssr&gt; &lt;f-block /&gt; &lt;f-block /&gt; &lt;f-block /&gt; &lt;/no-ssr&gt; &lt;/aside&gt; &lt;/div&gt;&lt;/template&gt;服务端渲染所需的数据在 asyncData 中获取，客户端渲染所需的数据在 mounted 钩子中获取:123456789101112131415161718192021222324export default { // 需要在服务端拉取的数据 async asyncData({ app, params }) { // 发送请求 const threadResultPromise = app.$api.thread.getThreadDetail(parseInt(params.tid, 10)) const replyListResultPromise = app.$api.thread.getThreadReplyList({ threadId: parseInt(params.tid, 10) }) return Promise.all([ threadResultPromise, replyListResultPromise ] =&gt; { return { // ... } }) }, // 在客户端获取的数据 mounted() { this.getSpecialColumnInfo() this.setContentTypeName() }}区分登录和非登录情况搜索引擎的爬虫，访问你的服务器的时候并不会携带用户相关的信息。所以我们可以针对这一特性来做进一步的优化，进一步的减少 node 服务器的渲染压力。这一步可以参考掘金社区，只在非登录的情况下做服务端渲染，用户登录的情况下就是客户端渲染。在 nuxt.js 中，可以编写一个渲染服务器中间件，来对登录用户和非登录用户进行不同的处理。如采用 cookie 来对用户是否登录进行判断：1234567891011121314151617181920const cookieparser = require('cookieparser')export default function (res, req, next) { try { const parsed = req.headers.cookie ? cookieparser.parse(req.headers.cookie) : '' // cookie 中存在用户信息 if (parsed &amp;&amp; parsed.userInfo) { // 置为 spa 模式 res.spa = true next() return } } catch (err) { throw err } next()}ssr 和 spa 的切换nuxt.js 的配置文件中，导出的一个 mode 属性，它的默认值为 universal 同构应用程序，提供的另外一个属性 spa 单页。想要在 ssr 和 spa 之间切换只需要更改 mode 的值，再重新编译即可：1234567module.exports = { // 服务端渲染 前端同构 mode: 'universal' // 客户端渲染 单页应用 // mode: 'spa'}部署策略服务端渲染，cpu 密集型的操作，高并发下很容易造成 cpu 满载，在我负责的服务端渲染的项目中，我采用的 pm2 来部署项目。pm2 是一个 node 进程管理工具，它可以对 node 应用进行监控，自动重启，负载均衡等。pm2 可以启动多个实例来用于负载均衡，多个 node 实例可以实现前端应用不停机更新。除了每个服务器启动 node 集群实现每个进程之间之外，还要多个服务器之间实现负载均衡，使用 nginx 实现多个服务器间的负载均衡。我们公司在部署的时候，就采用了 3 台 8 核的服务器进行负载均衡，每台服务器又开启 8 个 node 进程进行负载均衡。node 集群node 是基于 v8 引擎实现的在操作系统中运行 JavaScript 的工具，JavaScript 的单线程在多核的 cpu 上运行无法发挥多核 cpu 的性能，只有一个 cpu 核心在运行，其他的核在闲置，效率很低。在我负责的项目中，使用的是 pm2 实现 node 的集群，pm2 可以把你的应用以 集群（cluster）模式来运行(仅限 node 程序)，部署到服务器 cpu 的所有核心上。使用 pm2 来启动 nuxt 服务器可以在根目录下新建一个 pm2 启动描述文件：pm2.json:1234567891011121314151617{ \"apps\": [ { \"name\": \"feng-pc-render-server\", \"max_memory_restart\": \"1200M\", \"script\": \"server/index.js\", \"env\": { \"NODE_ENV\": \"production\", \"PORT\": 3000, \"HOST\": \"0.0.0.0\" }, \"instances\": 0, \"exec_mode\": \"cluster\", \"autorestart\": true } ]}其中 max_memory_restart 自动重启的最大内存，当进程内存超过该值时重启该进程，可以在一定程度上解决内存泄露，但这明显不是明智的选择，exec_mode 表示启动的模式，值为 cluster 时已集群的模式启动。instances 字段表示需要启动的 node 进程，当值为 0 或 max 时，pm2 已当前服务器所能启动的最多实例来启动项目，仅在 cluster 模式下生效。当使用 pm2 的集群模式启动后，使用 top 命令或 htop 查看服务器运行信息，可以看到服务器的 8 个核心，均有负载。此外，如果 cpu 核心少的话，也可以启动多个端口使用 nginx 进行负载均衡，但这样也起不了多少效果。nginx 集群在我所负责的服务端渲染项目中，是使用 nginx 对 3 台 8 核的服务器进行负载均衡。当用户访问服务端时，服务端通过 nginx 负载到其中资源利用率较低的一台，再反向代理到负载均衡的 node 集群，然后随机将用户的请求发给比较闲的node服务。在这个过程中也碰到了很多坑，如怎么在 3 台 服务器间进行状态同步，保持登录。由于我们公司的网络配置层是由运维去管理的，如何配置 nginx 负载均衡在这里不进行赘述，有兴趣的朋友可以自行搜索。防止 cc 攻击我们公司的网站也是国内流量比较大的社区类站点，项目在上线几个月后，遭遇了一次大规模的 cc 攻击，针对这种情况，我们也做了大量的处理：配置 ip 黑名单，对单个 ip 限制最大并发数、写 lua 脚本拦截 cc 攻击，最后还上了高防服务器。总结将 vue 渲染成 html 是 cpu 密集型的操作，node 又是单线程的，所以性能不是很好，想要提高并发，就得做缓存。在 node 渲染服务器中做三层的缓存：页面级别的缓存、组件级别的缓存、api 级别的缓存。由于搜索引擎的爬虫不会携带用户信息，还可以区分用户登录和非登录的情况，针对非登录用户做服务端渲染 ssr ，对登录用户做客户端渲染 spa。也不是所有页面都需要服务端渲染，可以仅针对特定的路由做服务端渲染，还要控制首屏的大小，非必要的组件使用懒加载的方式在客户端渲染，再加上多层的集群处理。","link":"/2020/05/13/浅谈 vue 前端同构框架 nuxt 及其性能优化/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"异步","slug":"异步","link":"/tags/异步/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"函数","slug":"函数","link":"/tags/函数/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"实战","slug":"实战","link":"/tags/实战/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"deepin","slug":"deepin","link":"/tags/deepin/"},{"name":"交换文件","slug":"交换文件","link":"/tags/交换文件/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"杂谈","slug":"杂谈","link":"/tags/杂谈/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/函数式编程/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"实习","slug":"实习","link":"/tags/实习/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"部署","slug":"部署","link":"/tags/部署/"},{"name":"gitlab-runner","slug":"gitlab-runner","link":"/tags/gitlab-runner/"},{"name":"持续集成","slug":"持续集成","link":"/tags/持续集成/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Canvas","slug":"Canvas","link":"/tags/Canvas/"},{"name":"学习计划","slug":"学习计划","link":"/tags/学习计划/"},{"name":"软件","slug":"软件","link":"/tags/软件/"},{"name":"浏览器","slug":"浏览器","link":"/tags/浏览器/"},{"name":"Safari","slug":"Safari","link":"/tags/Safari/"},{"name":"移动端","slug":"移动端","link":"/tags/移动端/"},{"name":"100vh","slug":"100vh","link":"/tags/100vh/"},{"name":"CSS flex","slug":"CSS-flex","link":"/tags/CSS-flex/"},{"name":"created","slug":"created","link":"/tags/created/"},{"name":"mounted","slug":"mounted","link":"/tags/mounted/"},{"name":"生命周期","slug":"生命周期","link":"/tags/生命周期/"},{"name":"异步请求","slug":"异步请求","link":"/tags/异步请求/"},{"name":"formidable","slug":"formidable","link":"/tags/formidable/"},{"name":"前端知识体系","slug":"前端知识体系","link":"/tags/前端知识体系/"},{"name":"学习","slug":"学习","link":"/tags/学习/"},{"name":"方法论","slug":"方法论","link":"/tags/方法论/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"登录拦截","slug":"登录拦截","link":"/tags/登录拦截/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"原型","slug":"原型","link":"/tags/原型/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"nuxt","slug":"nuxt","link":"/tags/nuxt/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"服务端渲染","slug":"服务端渲染","link":"/tags/服务端渲染/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/前端/JavaScript/"},{"name":"Node.js","slug":"后端/Node-js","link":"/categories/后端/Node-js/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/前端/HTML/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/前端/CSS/"},{"name":"浏览器","slug":"前端/浏览器","link":"/categories/前端/浏览器/"},{"name":"博客实战系列","slug":"后端/Node-js/博客实战系列","link":"/categories/后端/Node-js/博客实战系列/"},{"name":"Vue","slug":"前端/JavaScript/Vue","link":"/categories/前端/JavaScript/Vue/"},{"name":"爬坑","slug":"后端/Node-js/爬坑","link":"/categories/后端/Node-js/爬坑/"}]}