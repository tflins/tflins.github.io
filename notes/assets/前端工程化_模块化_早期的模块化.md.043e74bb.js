import{o as n,c as a,a as s}from"./app.57353960.js";const p='{"title":"早期的模块化","description":"","frontmatter":{},"relativePath":"前端工程化/模块化/早期的模块化.md","lastUpdated":1615827420160}',t={},o=s('<h1 id="早期的模块化"><a class="header-anchor" href="#早期的模块化" aria-hidden="true">#</a> 早期的模块化</h1><p>模块化主要是为了：</p><ul><li>解决命名冲突</li><li>污染全局作用域</li><li>可读性更高，更易于维护</li><li>代码复用性更强</li></ul><hr><p>早期的模块化主要是利用闭包加上立即执行函数来实现的，通过函数作用域解决了命名污染和污染全局作用域的问题。</p><p>如：</p><div class="language-js"><pre><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 模块内部</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div><p>将 <code>window</code> 对象传入立即执行函数中，主要目的是为了进一步的提高性能，可以更快的访问到 <code>window</code> 对象，避免查找至顶级作用域，在压缩混淆代码过程中，还可以优化代码，将 <code>window</code> 重命名为 <code>a</code> 这类字节长度更短的变量名。</p>',8);t.render=function(s,p,t,e,c,i){return n(),a("div",null,[o])};export default t;export{p as __pageData};
