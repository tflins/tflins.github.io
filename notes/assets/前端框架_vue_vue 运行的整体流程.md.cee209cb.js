import{o as e,c as a,a as n}from"./app.8c8a1ac2.js";const o='{"title":"vue 整体运行流程","description":"","frontmatter":{},"headers":[{"level":2,"title":"_init","slug":"init"},{"level":2,"title":"$mount","slug":"mount"},{"level":2,"title":"compiler","slug":"compiler"},{"level":2,"title":"vDom（虚拟 dom）","slug":"vdom（虚拟-dom）"}],"relativePath":"前端框架/vue/vue 运行的整体流程.md","lastUpdated":1615824181933}',s={},t=n('<h1 id="vue-整体运行流程"><a class="header-anchor" href="#vue-整体运行流程" aria-hidden="true">#</a> vue 整体运行流程</h1><hr><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> _init <span class="token operator">-</span><span class="token operator">&gt;</span> $mount <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> vDomTree <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Dom\n</code></pre></div><h2 id="init"><a class="header-anchor" href="#init" aria-hidden="true">#</a> _init</h2><p>_init 阶段，vue 会进行一系列的初始化操作，比如合并配置项、初始化生命周期、初始化事件中心、初始化渲染、初始化状态等。vue 的数据劫持就是在 initState 阶段进行的。</p><h2 id="mount"><a class="header-anchor" href="#mount" aria-hidden="true">#</a> $mount</h2><p>vue 中，分为 运行时编译(Runtime + compiler) 和 只运行时(Runtime Only) 两个版本，使用 Runtime Only 版本的时候，通常是使用 webpack 的 vue-loader 将 .vue 文件编译成 js，因为只包含运行时的代码，不包含编译的代码，所以 Runtime Only 版本的 vue.js 会更轻量。</p><p>Runtime + compiler 版本就会在运行时编译，比如你需要将 <code>template</code> 编译成 render 函数，就需要这个版本，这个版本包含 vue 的编译器。</p><h2 id="compiler"><a class="header-anchor" href="#compiler" aria-hidden="true">#</a> compiler</h2><p>vue 2.x 版本中，template 会被编译成 render 函数，运行 runder 函数得到 vNode。</p><p>编译可以分为 3 个阶段：<code>parse</code>、<code>optimize</code>、<code>generate</code>。</p><p><code>parse</code> 阶段会去解析 <code>template</code> ，将 vue 模板解析成 抽象语法树(AST)。</p><p><code>optimize</code> 阶段，会针对 <code>parse</code> 阶段生成的 AST 去进行优化。会去标记静态节点，因为静态的节点是不会去改变的，vue diff dom 的时候会跳过静态节点，这样会节省大量的编译时间。</p><p><code>generate</code> 阶段会将 AST 转换成可执行的 JavaScript 代码，也就是 render 函数。</p><p>这样经过 <code>parse</code> -&gt; <code>optimeze</code> -&gt; <code>generate</code> 3 个阶段，就可以将 template 编译成获取 vNode 所需的 render 函数了。</p><h2 id="vdom（虚拟-dom）"><a class="header-anchor" href="#vdom（虚拟-dom）" aria-hidden="true">#</a> vDom（虚拟 dom）</h2><p>虚拟 dom，就是一颗以 vNode 为节点的数，vNode 是一个以 JavaScript 对象的形式来描述真实 dom 节点的对象，是对真实 dom 的抽象。真实 dom 所包含的信息太多，操作真实 dom 需要昂贵的代价，而将真实 dom 抽象成 vNode，在内存中操作 vNode 最后再映射到真实 dom 上，可以极大程度的提高性能，并且可以实现跨平台，如在 weex 、node 或 浏览器中运行。</p>',17);s.render=function(n,o,s,p,r,c){return e(),a("div",null,[t])};export default s;export{o as __pageData};
